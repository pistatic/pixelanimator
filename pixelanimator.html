<!DOCTYPE html>
<html>
<head><title>PixelAnimator</title></head>
<link rel="shortcut icon" type="image/ico" href="favicon.ico" /> 
<style>*{
-moz-user-select: none; -webkit-user-select: none; -ms-user-select:none; user-select:none;}
canvas{    image-rendering: optimizeSpeed;
    image-rendering: -moz-crisp-edges;
    image-rendering: -webkit-optimize-contrast;
    image-rendering: optimize-contrast;
    -ms-interpolation-mode: nearest-neighbor;
    }
	
#mainoverlay{position:fixed;z-index:100; display:block; pointer-events:none;top:0;left:0;}

.drawcanv{ position:fixed; }
#drawoverlay{cursor: url(curpencil.cur),pointer;  position:fixed; z-index:98; }
#onioncanvas{ position:fixed; z-index:97; }
.drawheader{background:black; color:white; cursor:move; position:fixed; min-width:100px;top:0; line-height:25px; padding:0px 10px 0px 10px;  transition:color 1s;}
.drawheader_ina{background:#222222;color:gray;cursor:move;position:fixed; min-width:100px;top:0; line-height:25px; padding:0px 10px 0px 10px; transition:color 0.5s; }
.drawback{background:green;z-index:-1;position:fixed;}
#downloadTrigger{display:none;}
#saveTrigger{display:none;}
/*FloatingWindow*/
#fw_new{ 
    visibility:hidden; position:absolute; background:lightgray; border:2px solid #3c3c3c;
    color:black; z-index:100; width: 200px; height:auto; padding:5px;}

.dimmer{background: #000; position: fixed; opacity: .5;
    top:0; left:0; width:100%; height:100%; z-index:99; 
	}
.colorcube{width:17px;height:17px;border:2px solid black;    background:red; transition:border 0.3s; padding:0px; vertical-align:bottom; }
.colorcube2{width:17px;height:17px;border:2px solid #222222; background:red; transition:border 0.3s; padding:0px;  vertical-align:bottom; }
.colorcube:hover, .colorcube2:hover , .colorcube_act, .colorcube2_act  {border:2px solid #FFAA00; padding:0px; width:17px;height:17px; vertical-align:bottom;}
.colorcube_alt{width:100%; height:30%; bottom:0px; }

#colorswatch{width:60px;height:60px; margin:0px;}
.blockmenubutton{width:30px;height:30px; display:inline-block; margin:1px; background:#FFFFFF; transition:background 0.5s;}
.blockmenubutton_ina{width:30px;height:30px; display:inline-block; margin:1px; background:#888888;}
.blockmenubutton:hover{ background:#FFAA00; }
.blockmenuface{width:100%; height:100%;}

.menuheader{position:fixed; width:100%; margin:0; top:0; left:0; height:90px; background:black; color:white;}
.toolpack{ position:absolute;  top:10px; width:270px; display:block;  }
.tp1{/*tools*/ left:20px;}
.tp2{ /*edit*/ left:300px;}
.tp3{ /*file*/ right:250px;} 
.tp4{/*color*/ right:30px;} 
.tp5{/*pixan*/ height:100%; left:50%; min-width:200px; margin-left:-150px; text-align:center;}
.gradlight{background: -moz-linear-gradient(top,  rgba(255,255,255,0) 0%, rgba(255,255,255,0.47) 100%); /* FF3.6+ */
	background: -webkit-gradient(linear, left top, left bottom, color-stop(0%,rgba(255,255,255,0)), color-stop(100%,rgba(255,255,255,0.47))); /* Chrome,Safari4+ */
	background: -webkit-linear-gradient(top,  rgba(255,255,255,0) 0%,rgba(255,255,255,0.47) 100%); /* Chrome10+,Safari5.1+ */
	background: -o-linear-gradient(top,  rgba(255,255,255,0) 0%,rgba(255,255,255,0.47) 100%); /* Opera 11.10+ */
	background: -ms-linear-gradient(top,  rgba(255,255,255,0) 0%,rgba(255,255,255,0.47) 100%); /* IE10+ */
	background: linear-gradient(to bottom,  rgba(255,255,255,0) 0%,rgba(255,255,255,0.47) 100%); /* W3C */
	filter: progid:DXImageTransform.Microsoft.gradient( startColorstr='#00ffffff', endColorstr='#78ffffff',GradientType=0 ); /* IE6-9 */
	opacity:1; transition:opacity 1s;
	}
.bindsquare{background:#FFAA00;  position:absolute; width:15px;  height:15px; top:5px; right:5px; cursor:default;}
.helpbutton{background:#995500; position:absolute; left:10px;top:5px; border:none; font-weight:bold; height:20px; width:50px; transition:background 0.5s;}
.settingsbutton{background:#555555; position:absolute; left:10px;top:30px; border:none; font-weight:bold; height:20px; width:50px;}
.helpbutton:hover{background:#FEC80D;}
	</style>
	
	
	
<body style="background:lightgrey;">

    <div class="menuheader">
	<p id="debugp" style="position:absolute; top:80px;left:10px">debug</p>
	<div class="toolpack tp1">
		<div class="blockmenubutton" onclick="toolpick('pencil')" >				<img src="icons/block_pen.svg" title="Pencil" class="blockmenuface"></div>
		<div class="blockmenubutton_ina" onclick=";" >							<img src="icons/block_eraser.svg" title="Eraser" class="blockmenuface"></div>
		<div class="blockmenubutton" onclick="toolpick('rectselect')">			<img src="icons/block_rectselect.svg" title="Select" class="blockmenuface"></div>
		<div class="blockmenubutton" onclick="toolpick('fill')">				<img src="icons/block_fill.svg" title="Fill" class="blockmenuface"></div>
		<div class="blockmenubutton" onclick="toolpick('outlinefill');">		<img src="icons/block_fillcont.svg" title="Outline Fill" class="blockmenuface"></div>
		<div class="blockmenubutton" onclick="outline()">						<img src="icons/block_contour.svg" title="Outline" class="blockmenuface"></div>
		<br>
		
		<div class="blockmenubutton_ina" onclick=";">							<img src="icons/block_colorpicker.svg" title="Pick Color" class="blockmenuface"></div>
		<div class="blockmenubutton" onclick="toolpick('shading');">		<img src="icons/block_shade.svg" title="Shading Tool" class="blockmenuface"></div>
		<div class="blockmenubutton_ina" onclick="toolpick('free-select')">		<img src="icons/block_freeselect.svg" title="Free-select" class="blockmenuface"></div>
		<div class="blockmenubutton_ina" onclick=";">							<img src="icons/block_line.svg" title="Line Tool" class="blockmenuface"></div>
		<div class="blockmenubutton_ina" onclick=";">							<img src="icons/block_rect.svg" title="Rectangle Tool" class="blockmenuface"></div>
		<div class="blockmenubutton_ina" onclick=";">							<img src="icons/block_oval.svg" title="Oval Tool" class="blockmenuface"></div>
		
		
		
	

		
	</div>
	


	

	
	<div class="toolpack tp2">
		<div class="blockmenubutton" onclick="undoHandler();" >					<img src="icons/block_undo.svg" title="Undo" class="blockmenuface"></div>
		<div class="blockmenubutton" onclick="redoHandler();" >					<img src="icons/block_redo.svg" title="Redo" class="blockmenuface"></div>
		<div class="blockmenubutton" onclick="localCopyHandler();" >			<img src="icons/block_copy.svg" title="Copy" class="blockmenuface"></div>
		<div class="blockmenubutton" onclick="localPasteHandler();" >			<img src="icons/block_paste.svg" title="Paste" class="blockmenuface"></div>
		<div class="blockmenubutton_ina" onclick=";" >							<img src="icons/block_cut.svg" title="Cut" class="blockmenuface"></div>
		&nbsp
		<div class="blockmenubutton_ina" onclick=";" >							<img src="icons/block_mirrorvert.svg" title="Flip Vertically" class="blockmenuface"></div>
		<div class="blockmenubutton_ina" onclick=";" >							<img src="icons/block_mirrorhor.svg" title="Flip Horizontally" class="blockmenuface"></div>
		<br>
		<div class="blockmenubutton" onclick="addFrame()">						<img src="icons/block_addframe.svg" title="Insert Frame" class="blockmenuface"></div>
		<div class="blockmenubutton" onclick="removeFrame()">					<img src="icons/block_deleteframe.svg" title="Remove Frame" class="blockmenuface"></div>
		<div class="blockmenubutton_ina" onclick=";" >							<img src="icons/block_copyframe.svg" title="Copy Frame" class="blockmenuface"></div>
		<div class="blockmenubutton_ina" onclick=";" >							<img src="icons/block_pasteframe.svg" title="Paste Frame" class="blockmenuface"></div>
		<div class="blockmenubutton_ina" onclick=";" >							<img src="icons/block_cutframe.svg" title="Cut Frame" class="blockmenuface"></div>
		&nbsp
		<div class="blockmenubutton_ina" onclick=";" >							<img src="icons/block_rotateleft.svg" title="Rotate Clockwise" class="blockmenuface"></div>
		<div class="blockmenubutton_ina" onclick=";" >							<img src="icons/block_rotateright.svg" title="Rotate Counterclockwise" class="blockmenuface"></div>
	</div>
	
	
	<div class="toolpack tp3">
		<div class="blockmenubutton" onclick="openfw(document.getElementById('fw_new'))" > <img src="icons/block_newsheet.svg" title="New Spritesheet" class="blockmenuface"></div>
		<div class="blockmenubutton" onclick="importHandler();" >				<img src="icons/block_opensheet.svg" title="Open Spritesheet" class="blockmenuface"></div>
		<div class="blockmenubutton" onclick="exportHandler();" >				<img src="icons/block_savesheet.svg" title="Save Spritesheet" class="blockmenuface"></div>
		<br>
		<div class="blockmenubutton_ina" onclick=";" > 							<img src="icons/block_newproj.svg" title="New Project" class="blockmenuface"></div>
		<div class="blockmenubutton_ina" onclick=";" > 							<img src="icons/block_openproj.svg" title="Open Project" class="blockmenuface"></div>
		<div class="blockmenubutton_ina" onclick=";" > 							<img src="icons/block_saveproj.svg" title="Save Project" class="blockmenuface"></div>
	</div>
	
	
	
	<div class="toolpack tp4">
		<input  type="color" id="colorswatch" onchange="colorpickchange({m:{r:hexToR(this.value),g:hexToG(this.value),b:hexToB(this.value)}})">
		<table id="colorgrid" style="position:absolute;top:0px;left:70px;margin:0; border:1px solid #222222;border-collapse: separate;border-spacing: 0px;">
		 <tr> 
			<td rowspan="3"> 
							<img width=20px; height=20px; id="colorlockbutton" src="icons/mini_lockopen.svg" title="Lock Colors"  
							
							onclick="if(colorslocked){colorslocked=false;
						this.src='icons/mini_lockopen.svg'}else{colorslocked=true;this.src='icons/mini_lockclosed.svg'}"
						</td> 
		</tr>
		 <tr> </tr>
		 <tr> </tr>
		</table>
	</div>
	<div class="toolpack tp5">
		<img src="icons/pixan.svg">
		<input class="helpbutton "type="button" value="HELP" onclick="window.open('pixanhelp.html');">
		<input class="settingsbutton "type="button" value="CONF" onclick=";">
	</div>
	
	<select style="display:none" onchange="pencilpick(this.value)" id="pencilselect">
		<option value="1">.</option>
		<option value="2">.</option>
		<option value="3">+</option>
	</select>
	
	
	<a target="_blank" href="" onclick="exportstart(this)" download="testXXX.jpg" id="downloadTrigger">DOWNLOAD ME!</a>
	<a target="_blank" href="" onclick="savestart(this)" download="" id="saveTrigger"></a>
	<input style="display:none;" type='file' name='img' id='uploadimage' onchange="filepick(this.value)" />
	
	</div>
	

<canvas id="mainoverlay" width="800" height="600" ></canvas> 

<canvas id="drawoverlay" width="800" height="600" ></canvas> 
<canvas id="onioncanvas" width="800" height="600" ></canvas> 
<canvas id="drawback" class="drawback gradlight" width="800" height="600" ></canvas> 

<div id="timelinediv" style="width:100%; height:auto; overflow:scroll; padding:0px; position:fixed; bottom:0; left:0;">
	
	<div id="timelinepicker" style="pointer-events:none; position:absolute; border: 2px solid red; width:50px;height:60px; display:inline-block;">e</div>
	<div id="timelineonionmin" style="pointer-events:none; position:absolute; border: 2px solid yellow; width:50px;height:60px; display:inline-block; visibility:hidden;"><</div>
	<div id="timelineonionmax" style="pointer-events:none; position:absolute; border: 2px solid yellow; width:50px;height:60px; display:inline-block; visibility:hidden;">></div>
</div>
<div id="viewsettingsdiv" style="width:100%; padding:0px; position:fixed; bottom:0; left:0; background:black; color:white;">
<button onclick="animate()">Play</button>
fps:<input type="number" value=15 min=1 id="fpsinput" style="width:40px;">
zoom:×<input type="number" value=5 min=1 id="zoominput" style="width:40px;">
&nbsp &nbsp || &nbsp &nbsp
<button onclick="toggleOnion()" id="oniButton"> Onion Toggle</button>


</div>
<br>


<div id="fw_new">
	New sheet <br>
	spw <input type="number" value=50 min=1 id="fwv_spw" style="width:40px;"> <br>
	sph <input type="number" value=60 min=1 id="fwv_sph" style="width:40px;"> <br>
	count <input type="number" value=12 min=1 id="fwv_count" style="width:40px;"> <br>
	<button onclick="createnewwindow(document.getElementById('fwv_spw').value,document.getElementById('fwv_sph').value,document.getElementById('fwv_count').value)">New</button> <button onclick="dimmer.click()">Cancel</button>
</div>

<br>

<br>



<script src="gildas-zip/zip.js"></script> 
<script>zip.workerScriptsPath="gildas-zip/"</script>

<script src="jquery-1.11.0.min.js"></script>
<script>


function windowresize() {
            mainoverlay.width = window.innerWidth;
            mainoverlay.height = window.innerHeight;
			}

function btnspawn(){
var btn=document.createElement("BUTTON");
document.body.appendChild(btn);
};



function canvasresize( wid, hei){trace(wid);
var resizebuff = aw.realctx.getImageData(0,0,aw.realc.width,aw.realc.height);
aw.realc.width=wid;
aw.realc.height=hei;
aw.spc = spc = Math.floor(wid/spw);
aw.realctx.putImageData(resizebuff,0,0);		
};

function addFrame(){
	var resizebuff1; var resizebuff2;
	if(currentframe!=0)     resizebuff1 = aw.realctx.getImageData(0,0,aw.spw*currentframe,aw.realc.height);
	if(currentframe<aw.spc) resizebuff2 = aw.realctx.getImageData(aw.spw*currentframe,0, aw.realc.width-aw.spw*currentframe ,aw.realc.height);
	aw.realc.width=aw.realc.width+spw;
	if(currentframe!=0)     aw.realctx.putImageData(resizebuff1,0,0);	
	if(currentframe<aw.spc) aw.realctx.putImageData(resizebuff2,(currentframe+1)*aw.spw,0);	
	setcurrentframe(currentframe);
	aw.spc = spc = Math.floor(aw.realc.width/aw.spw);
	}



function removeFrame(){trace(aw.spc.toString()+" "+currentframe.toString())
	var resizebuff1; var resizebuff2;
	if(currentframe!=0)     resizebuff1 = aw.realctx.getImageData(0,0,aw.spw*currentframe,aw.realc.height);
	if(currentframe<aw.spc-1) resizebuff2 = aw.realctx.getImageData(aw.spw*(currentframe+1),0, aw.realc.width-aw.spw*(currentframe+1) ,aw.realc.height);
	aw.realc.width=aw.realc.width-spw;
	if(currentframe!=0)     aw.realctx.putImageData(resizebuff1,0,0);	
	if(currentframe<aw.spc-1) aw.realctx.putImageData(resizebuff2,currentframe*aw.spw,0);	
	setcurrentframe(currentframe);
	aw.spc = spc = Math.floor(aw.realc.width/aw.spw);
}



function setTimelinePicker(){ //set
  var tlpicker=document.getElementById("timelinepicker");
  var tlonimin=document.getElementById("timelineonionmin");
  var tlonimax=document.getElementById("timelineonionmax");
  
  tlpicker.style.left=(currentframe*spw+5).toString()+"px"; 
  tlpicker.innerHTML=currentframe; 
   if(aw.onion){
	tlonimin.style.left=((currentframe-aw.onimin)*spw+5).toString()+"px"; 
	tlonimax.style.left=((currentframe+aw.onimax)*spw+5).toString()+"px"; 
   }
  }

function setupTimelinePicker(){ //setup
  var tlpicker=document.getElementById("timelinepicker");
  var tlonimin=document.getElementById("timelineonionmin");
  var tlonimax=document.getElementById("timelineonionmax");
  tlpicker.style.color="red";
  tlpicker.style.width = tlonimin.style.width = tlonimax.style.width = (spw-10).toString()+"px";
  tlpicker.style.height = tlonimin.style.height = tlonimax.style.height = (sph-10).toString()+"px";
  tlpicker.style.top  = tlonimin.style.top = tlonimax.style.top = "5px";

  setTimelinePicker();

  viewsettingsdiv.style.bottom=(sph+25).toString() +"px"; 
}




/*function applyzoom(){
var zoombuff = aw.realctx.getImageData(0,0,aw.realc.width,aw.realc.height).data; alert(zoombuff.length);
for(var i=0;i<zoombuff.length;i++){ctx.fillStyle="#000000"; ctx.fillRect((i/aw.realctx.width)*zoomv,(i%aw.realctx.width)*zoomv,zoomv,zoomv);}
} */

function trace(mit){
	document.getElementById("debugp").innerHTML = mit.toString();}

function setzoom(zv){ 
	aw.zoomv=zoomv=zv;  //c=document.getElementById("drawcanvas");
	dback.width=overc.width=onionc.width=c.width = spw*zoomv;
	dback.height=overc.height=onionc.height=c.height = sph*zoomv;
	ctx.imageSmoothingEnabled = false;ctx.webkitImageSmoothingEnabled = false;ctx.mozImageSmoothingEnabled = false;
	onionctx.imageSmoothingEnabled = false; onionctx.webkitImageSmoothingEnabled = false; onionctx.mozImageSmoothingEnabled = false;
	setcurrentframe(currentframe);
	drawheader.style.width = spw*zoomv - 20 + 'px';
	

	}

function copy()
{
var imgData=ctx.getImageData(10,10,50,50);
ctx.putImageData(imgData,10,70);
}




/*
var img2 = new Image();
img2.src = 'http://upload.wikimedia.org/wikipedia/commons/f/f0/Pixelart-tv-iso.png';

img2.onload = function () { 
        ctx.drawImage(aw.realc, 0, 0, aw.realc.width*zoomv, aw.realc.height*zoomv);
};
*/
function openfw(mit){
        dimmer = document.createElement("div");
		dimmer.className = 'dimmer';
    
    dimmer.onclick = function(){
        document.body.removeChild(this);   
        mit.style.visibility = 'hidden';
    }
        
    document.body.appendChild(dimmer);
    
    mit.style.visibility = 'visible'; 
    mit.style.top = window.innerHeight/2 - 50 + 'px';
    mit.style.left = window.innerWidth/2 - 100 + 'px';
    return false;

};
function createnewwindow(width,height,count){
	if(dimmer)dimmer.click();
	
	
	
	//id name aw.realc (aw.realctx) (drawcanvas) (drawctx) (drawheader) (undobuff) (redobuff) spw sph spc zoomv fpsv (currentframe)
	//changing: (tempc) (overc) (onionc) ---(timeline) (play)
	var rec={
	id:1,
	name:"new",
	realc:document.createElement('canvas'),
	drawc:document.createElement('canvas'),
	drawheader:document.createElement('div'),
	spw:parseInt(width),
	sph:parseInt(height),
	spc:parseInt(count),
	currentframe:0,
	zoomv:4,
	fpsv:15,
	onion:false,
	onimin:0,
	onimax:0,
	/*temp*/ bind:null,
	undobuff:new Array(),
	redobuff:new Array(),
	setAsActive:new Function()
	}
	rec.drawctx=rec.drawc.getContext('2d');
	rec.realctx=rec.realc.getContext('2d');
	rec.realc.width=rec.spw*rec.spc;  rec.realc.height=rec.sph; 
	rec.realc.addEventListener('mousedown',framepick , false);
	
	windowList.push(rec);
	
	
	
	
	
	document.body.appendChild(rec.drawc);
	document.body.appendChild(rec.realc);
	document.body.appendChild(rec.drawheader);
	
	rec.drawheader.className ="drawheader"
	rec.drawheader.innerHTML=rec.name+"<div class='bindsquare' title='bind'></div>";
	rec.drawheader.parentRec=rec;
	rec.drawc.className ="drawcanv";
	
	
	
	rec.setAsActive = function(){ 
	/*previously actives*/
		if(aw.realc){//on the first setasactive realc is undefined
		aw.realc.style.display="none";
		aw.drawheader.className="drawheader_ina";
		commitTemp();
		}//else 
	
	aw=rec;
	aw.realc.style.display="initial";
	aw.drawheader.className="drawheader";
	
	drawheader=rec.drawheader;
	currentWindowId=rec.id;
	//aw.realc=rec.realc;
	//aw.realctx=rec.realc.getContext('2d'); /*aw.realctx-et nem kell tárolni?*/ de
	c=rec.drawc;
	ctx=rec.drawctx;
	spw=rec.spw;
	sph=rec.sph;
	spc=rec.spc;
	currentframe=rec.currentframe;
	zoomv=rec.zoomv;
	fpsv=rec.fpsv;
	//onion=rec.onion; onimin=rec.onimin; onimax=rec.onimax;
	
	undobuff=rec.undobuff;
	redobuff=rec.redobuff;
	
	 
	 tempc.width=spw;  tempc.height=sph; 
	 
	 document.getElementById('zoominput').value=zoomv;
	 setzoom(zoomv);
	 setupTimelinePicker();
	//setcurrentframe(currentframe);
	
	 }
	 rec.setAsActive();
	
	document.getElementById("timelinediv").appendChild(aw.realc);
	drawheaderinit(200,200);
	
	
	drawheader.addEventListener('mousedown', drawheaderdragstart, false);
	
}




function framepick(e){if(!animrunning){ commitTemp();
 mouseX=(event.pageX - $(document).scrollLeft() - $(aw.realc).offset().left);
 var framenum=Math.floor(mouseX/spw);
 if(e.button==0){ currentframe=framenum }
 if(e.button==2 && aw.onion){if(framenum<currentframe) aw.onimin=currentframe-framenum;
						else if(framenum>currentframe) aw.onimax=framenum-currentframe;}
setcurrentframe(currentframe);
//trace(framenum)
}}

function setcurrentframe(currentframe)
{
  ctx.clearRect(0,0,spw*zoomv,sph*zoomv);
  ctx.drawImage(aw.realc, spw*currentframe, 0,  spw,sph,0,0,spw*zoomv,sph*zoomv);
  setTimelinePicker();
  aw.currentframe=currentframe;
  if(!animrunning){
	if(aw.onion) setonion();
	if(aw.bind!=null) setcurrentframe2(aw.bind,currentframe); }
 
}
function setcurrentframe2(tw,currentframe) //targetwindow
{

  tw.drawctx.clearRect(0,0,tw.spw*tw.zoomv,tw.sph*tw.zoomv);
  tw.drawctx.drawImage(tw.realc, tw.spw*currentframe, 0,  tw.spw,tw.sph,0,0,tw.spw*tw.zoomv,tw.sph*tw.zoomv);
}
function clearonion(){
  onionctx.clearRect(0,0,spw*zoomv,sph*zoomv);
}
function setonion(){
  clearonion();
  if(aw.onion){
  onionctx.globalAlpha = 0.2;
  onionctx.drawImage(aw.realc, spw*(currentframe-aw.onimin), 0,  spw,sph,0,0,spw*zoomv,sph*zoomv);
  onionctx.drawImage(aw.realc, spw*(currentframe+aw.onimax), 0,  spw,sph,0,0,spw*zoomv,sph*zoomv);
  }
}

function toggleOnion(){
  aw.onion=!aw.onion;
  var tlonimin=document.getElementById("timelineonionmin");
  var tlonimax=document.getElementById("timelineonionmax");
  if(aw.onion){tlonimin.style.visibility = tlonimax.style.visibility = "visible";}
  else{tlonimin.style.visibility = tlonimax.style.visibility = "hidden";}
  setcurrentframe(currentframe);
  setonion();
}

function applytemp()
{
  ctx.drawImage(tempc, 0, 0,  spw,sph,0,0,spw*zoomv,sph*zoomv);
}
function commitTemp(){ 
vanselect=false; softselect=false;
	if(undobuff.length>=undoDepth)undobuff.shift();
	var undostep = aw.realctx.getImageData( aw.spw*aw.currentframe, 0,  aw.spw,aw.sph);
	var undorec = {windowId:1, frame:currentframe, data:undostep};
	undobuff.push(undorec);
	if(redobuff.length>0)redobuff=new Array();
aw.realctx.drawImage(tempc, aw.spw*currentframe, 0); tempctx.clearRect(0,0,aw.spw,aw.sph);	

overctx.clearRect(0,0,aw.spw*zoomv,aw.sph*zoomv);

}



	//requestinterval csak 60fps-nél kellene
	var timer;
function animate()
{
if(!animrunning){currentframe=0;animrunning=true;
	clearonion();
   //TIMER

   timer = setInterval(function() {
   //elem.style.left = ( left += 10 ) + "px";
   setcurrentframe(currentframe);
   currentframe++;
   if ( currentframe>aw.spc ) {clearInterval( timer ); animrunning=false; currentframe=0; ctx.drawImage(aw.realc, spw*currentframe, 0,  spw,sph,0,0,spw*zoomv,sph*zoomv);}
   }, 1000/fpsv);
 }else /*if animrunning*/
   {clearInterval( timer ); animrunning=false; setcurrentframe(currentframe);}
};


function drawheaderinit(xp,yp){
  var div = drawheader;
  var canv = c; var ocanv = overc;
  div.style.top = yp + 'px';
  div.style.left = xp + 'px';
  dback.style.top=ocanv.style.top=onionc.style.top=canv.style.top = yp + 25 + 'px';
  dback.style.left=ocanv.style.left=onionc.style.left=canv.style.left = xp + 'px';
  div.getElementsByClassName("bindsquare")[0].addEventListener('contextmenu', rightclickmenu  , false);
  }

function drawheaderdragstart(e){
  if(this.parentRec!=aw)
     {this.parentRec.setAsActive(); 
	 drawback.style.transition="opacity 0s"; drawback.style.opacity=0; }
	 
  if(e.button==0) //leftclick
	{
	window.addEventListener('mousemove', drawheaderdragmove, true);
	window.addEventListener('mouseup', drawheaderdragend, true);
	dhdstartX=e.clientX + $(document).scrollLeft() - $(drawheader).offset().left;
	dhdstartY=e.clientY + $(document).scrollTop() - $(drawheader).offset().top;
	drawheaderdragmove(e);
	drawback.style.transition="opacity 1s"; drawback.style.opacity=1;
	
	if(document.elementFromPoint(e.clientX,e.clientY).className=="bindsquare") 
		{bindInProgress=true;
		dhdstartX=e.clientX ; dhdstartY=e.clientY ;  
		mainoverctx.strokeStyle="#FFAA00";  mainoverctx.lineWidth=2;}
	}
	
  else if(e.button==2) //rightclick
	{if(document.elementFromPoint(e.clientX,e.clientY).className=="bindsquare"){ aw.bind=null; 	 }  
	}
 
  }
function drawheaderdragmove(e){
  var div = drawheader;
  if(!bindInProgress){// window moving
	var canv = c; var ocanv = overc;
	div.style.top = e.clientY -dhdstartY + 'px';
	div.style.left = e.clientX -dhdstartX+ 'px';
	dback.style.top=ocanv.style.top=onionc.style.top=canv.style.top = e.clientY -dhdstartY + 25 + 'px';
	dback.style.left=ocanv.style.left=onionc.style.left=canv.style.left = e.clientX -dhdstartX + 'px';
	}
  else{ //binding
  mainoverctx.clearRect(0,0,mainoverc.width,mainoverc.height);
  mainoverctx.beginPath();
  mainoverctx.moveTo(dhdstartX,dhdstartY);
  mainoverctx.lineTo(e.clientX,e.clientY);
  mainoverctx.stroke();
  }
}
function drawheaderdragend(e){
  window.removeEventListener('mousemove', drawheaderdragmove, true);
  window.removeEventListener('mouseup', drawheaderdragend, true);
  bindInProgress=false;
  mainoverctx.clearRect(0,0,mainoverc.width,mainoverc.height);
  if(document.elementFromPoint(e.clientX,e.clientY).className=='drawheader_ina')
	{aw.bind=document.elementFromPoint(e.clientX,e.clientY).parentRec};
}




	
	function rightclickmenu(e){e.preventDefault(); return false;}
	
	  function drawevent (e) {
    var func = tool[e.type];
	
    if (func) { func(e); }
  }
  
function toolpick (e) {
  commitTemp();
   tool=new tools[e];
      //tool = tools.pencil;//new tools[this.value]();
	  
    //}
  }
  

 function pencilpick(e){ //alert(e);
	switch(e){
	case "1": drawpixel = tempctx.createImageData(1,1); 
			drawpixel.data[0]=col.r;
			drawpixel.data[1]=col.g;
			drawpixel.data[2]=col.b;
			drawpixel.data[3]=255; 
			var drawpixelsize = 1; break;
	case "2": drawpixel = tempctx.createImageData(2,2);
			for(var i=0;i<4;i++){
			drawpixel.data[0+i*4]=col.r;
			drawpixel.data[1+i*4]=col.g;
			drawpixel.data[2+i*4]=col.b;
			drawpixel.data[3+i*4]=255;} 
			var drawpixelsize = 2; break;
	case "3":	drawpixel = tempctx.createImageData(3,3);
			for(var i=0;i<9;i++){
			drawpixel.data[0+i*4]=col.r;
			drawpixel.data[1+i*4]=col.g;
			drawpixel.data[2+i*4]=col.b;
			drawpixel.data[3+i*4]=255;} 
			var drawpixelsize = 3; break;
	
 }
 }

 
 
 
 
 
 
 
 
 var undoDepth=50;
var animrunning=false;

var windowList=new Array(); /*records of open windows and their settings*/

var aw=new Object(); //ActiveWindow
//id name aw.realc (aw.realctx) (drawcanvas) (drawctx) (drawheader) (undobuff) (redobuff) spw sph spc zoomv fpsv (currentframe)
//pure global
var drawheader;
var zoomv=5;
var fpsv=15;
var currentframe=0;
var spw=50; //spritewidth
var sph=60;
var spc=30; //spritecount
var undobuff=new Array();
var redobuff=new Array();
var onion=false;
var onimin=0;
var onimax=0;

/*temp*/var bind=null;

var col={r:0,g:0,b:0};
var selx=0; var sely=0;var selw=0; var selh=0;
var dimmer;
var ctrlOn=false;
var shiftOn=false;
var bindInProgress=false;

var colorslocked=false;
var currentColorIndex=0;
var junkColorIndex=-1;
var colorList;

    var drawpixel ;
  var drawpixelsize ;
  var erasepixel ;
  
  var mainoverc;
  var dback;
var overc;
var onionc;
var overctx;
var onionctx;
var tempc; 
var tempctx ;
var dumpc ; 
var dumpctx ;

 /*ONLOAD*/
 window.onload=function(){
 

colorList=new Array(  {m:{r:0,g:0,b:0}, a:null},		{m:{r:255,g:255,b:255},a:null},		{m:{r:255,g:0,b:0}, a:{r:200,g:0,b:0}},		{m:{r:0,g:255,b:0}, a:{r:0,g:200,b:0}},		{m:{r:0,g:0,b:255}, a:{r:0,g:0,b:200}},		{m:{r:125,g:0,b:125}, a:{r:100,g:0,b:100}},
						  {m:{r:255,g:125,b:0}, a:null},	{m:{r:255,g:255,b:0},a:null},		{m:{r:255,g:0,b:255}, a:null},				{m:{r:0,g:255,b:255}, a:null},				{m:{r:125,g:125,b:125}, a:null},				{m:{r:0,g:125,b:0}, a:null}  ,
						  
						  {m:{r:125,g:125,b:125}, a:null},  {m:{r:125,g:125,b:125}, a:null},	{m:{r:125,g:125,b:125}, a:null},			{m:{r:125,g:125,b:125}, a:null},			{m:{r:125,g:125,b:125}, a:null},			{m:{r:125,g:125,b:125}, a:null} );
						 


//var tool="pencil";
 
setupTimelinePicker();
 window.addEventListener('resize', windowresize, false);
windowresize();
 mainoverc=document.getElementById("mainoverlay");
mainoverctx=mainoverc.getContext("2d");

 dback=document.getElementById("drawback");
 overc=document.getElementById("drawoverlay");
 onionc=document.getElementById("onioncanvas");
 overctx=overc.getContext("2d");
 onionctx=onionc.getContext("2d");
	onionctx.globalAlpha = 0.5;
    //aw.realc = document.getElementById("realcanvas"); //createElement('canvas');
    //aw.realctx = aw.realc.getContext('2d');

 tempc = document.createElement('canvas'); 
document.body.appendChild(tempc);tempc.style.position="fixed";tempc.style.top="100px";tempc.style.left="5px";
 tempc.width=spw;  tempc.height=sph; 

 tempctx = tempc.getContext('2d');

 dumpc = document.createElement('canvas'); 
 dumpctx = dumpc.getContext('2d');


//document.body
//document.getElementById("timelinediv").appendChild(aw.realc);

$('#fpsinput').bind('input', function() { fpsv=$(this).val(); });/*nem rakhatom c inicializálás elé*/
$('#zoominput').bind('input', function() { setzoom( $(this).val() ); }  ); /*nem rakhatom ctx beállítások után mert elmos; wtfff*/


        /*ctx.imageSmoothingEnabled = false;
        ctx.webkitImageSmoothingEnabled = false;
        ctx.mozImageSmoothingEnabled = false;*/
		
        onionctx.imageSmoothingEnabled = false;
        onionctx.webkitImageSmoothingEnabled = false;
        onionctx.mozImageSmoothingEnabled = false;
  createnewwindow(50, 60, 12);
  drawheaderinit(150,150);
  setzoom(zoomv);
  fpsv=aw.fpsv=15;
  document.getElementById('fpsinput').value=15;
  setcurrentframe(currentframe);


     drawoverlay.addEventListener('mousedown', drawevent, false);
	drawoverlay.addEventListener('touchstart', drawevent, false);
    window.addEventListener('mousemove', drawevent, false);
	window.addEventListener('touchmove', drawevent, false);
	window.addEventListener('mouseup', drawevent, false);
    window.addEventListener('touchend',   drawevent, false);
	drawoverlay.addEventListener('mouseout',   drawevent, false);
	drawoverlay.addEventListener('touchleave',   drawevent, false);
	
	/*window*/drawoverlay.addEventListener('contextmenu', rightclickmenu  , false);
	document.getElementById("timelinediv").addEventListener('contextmenu', rightclickmenu  , false);
 
     drawpixel = tempctx.createImageData(2,2);;
   drawpixelsize = 2;
   erasepixel = tempctx.createImageData(2,2); 
  
 pencilpick("1");
 for(var i=0;i<16;i++) erasepixel.data[i]=255;
   var colorgrid = document.getElementById("colorgrid");

  for(var i=0; i<18; i++){
    var setcol=colorList[i]; 
	var newcell = colorgrid.rows[Math.floor(i/6)].insertCell(i%6);
	if(i<12) newcell.className="colorcube";
	else     newcell.className="colorcube2";
	newcell.style.background=rgbToHex(setcol.m.r,setcol.m.g,setcol.m.b);
	//newcell.value=rgbToHex(setcol.m.r,setcol.m.g,setcol.m.b);
	if(setcol.a!=null)newcell.innerHTML="<div class='colorcube_alt' style='background:"+rgbToHex(setcol.a.r,setcol.a.g,setcol.a.b)+"'></div>";
	newcell.target=i;
	newcell.onclick= function(){colorGridPick(this.target);};
  }
  
  }
 /*-----*/
 
 
  

function componentToHex(c) {var hex = c.toString(16); return hex.length == 1 ? "0" + hex : hex;}
function rgbToHex(r, g, b) {return "#" + componentToHex(r) + componentToHex(g) + componentToHex(b);}

function hexToR(h) {return parseInt((cutHex(h)).substring(0,2),16)}
function hexToG(h) {return parseInt((cutHex(h)).substring(2,4),16)}
function hexToB(h) {return parseInt((cutHex(h)).substring(4,6),16)}
function cutHex(h) {return (h.charAt(0)=="#") ? h.substring(1,7):h}
function colorpick (e) {
  col.r=e.m.r//hexToR(e);
  col.g=e.m.g//hexToG(e);
  col.b=e.m.b//hexToB(e);
  pencilpick(document.getElementById("pencilselect").value);
  document.getElementById("colorswatch").value=rgbToHex(col.r, col.g, col.b);
  }
function colorpickchange(e){
	/*--kell--search for color*/
  if(!colorslocked){ 
	colorList[currentColorIndex].m={r:e.m.r, g:e.m.g, b:e.m.b}; 
	colorgrid.rows[Math.floor(currentColorIndex/6)].cells[currentColorIndex%6].style.background=rgbToHex(e.m.r,e.m.g,e.m.b);
	colorpick (e);
	}
  else{ 
	
	if(!matchCol({r:e.m.r, g:e.m.g, b:e.m.b},colorList[12+(junkColorIndex+6)%6].m)) junkColorIndex++; 
	tempColorIndex=12+junkColorIndex%6; 
	colorList[tempColorIndex].m={r:e.m.r, g:e.m.g, b:e.m.b}; 
	colorgrid.rows[Math.floor(tempColorIndex/6)].cells[tempColorIndex%6].style.background=rgbToHex(e.m.r,e.m.g,e.m.b);
	colorGridPick(tempColorIndex);
  }
}

function colorpickaltchange(e){
	/*--kell--search for color*/
  if(!colorslocked){ 
	colorList[currentColorIndex].a={r:e.m.r, g:e.m.g, b:e.m.b}; 
	colorgrid.rows[Math.floor(currentColorIndex/6)].cells[currentColorIndex%6].innerHTML="<div class='colorcube_alt' style='background:"+rgbToHex(e.m.r, e.m.g, e.m.b)+"'></div>";
	colorpick (e);
	}
  /*else{ 
	
	if(!matchCol({r:e.m.r, g:e.m.g, b:e.m.b},colorList[12+(junkColorIndex+6)%6].m)) junkColorIndex++; 
	tempColorIndex=12+junkColorIndex%6; 
	colorList[tempColorIndex].m={r:e.m.r, g:e.m.g, b:e.m.b}; 
	colorgrid.rows[Math.floor(tempColorIndex/6)].cells[tempColorIndex%6].style.background=rgbToHex(e.m.r,e.m.g,e.m.b);
	colorGridPick(tempColorIndex);
  }*/
}

  

  /*

for(var i=0; i<colorgrid.rows.length;i++){
for(var j=0; j<colorgrid.rows[i].cells.length;j++){

		var setcol=startColors[i*colorgrid.rows[i].cells.length + j]; 
		colorgrid.rows[i].cells[j].style.background=rgbToHex(setcol.r,setcol.g,setcol.b);
		colorgrid.rows[i].cells[j].value=rgbToHex(setcol.r,setcol.g,setcol.b);
	colorgrid.rows[i].cells[j].onclick= function(){colorGridPick(this.value);};
}}  */



function colorGridPick(e){
	colorpick(colorList[e]);
	colorgrid.rows[Math.floor(currentColorIndex/6)].cells[currentColorIndex%6].className = currentColorIndex<12 ? "colorcube" : "colorcube2";
	colorgrid.rows[Math.floor(e/6)].cells[e%6].className= "colorcube_act" ;
	currentColorIndex=e;}
  
  
  
function matchCol(a,b){
	if(a.hasOwnProperty("a") && b.hasOwnProperty("a")) return(a.r==b.r && a.b==b.b && a.g==b.g && a.a==b.a);
	else return(a.r==b.r && a.b==b.b && a.g==b.g);
}
function getCol(pic,px,py){
	var col=new Object();
	var pos=(px+py*spw)*4;
	col.r=pic.data[pos];
	col.g=pic.data[pos+1];
	col.b=pic.data[pos+2];
	col.a=pic.data[pos+3];
	return col;
}
function setCol(pic,px,py,col){
	var pos=(px+py*spw)*4;
	pic.data[pos]=col.r;
	pic.data[pos+1]=col.g;
	pic.data[pos+2]=col.b;
	pic.data[pos+3]=255;
}
function setCol32(pic,px,py,col){
	var pos=(px+py*spw)*4;
	pic.data[pos]=col.r;
	pic.data[pos+1]=col.g;
	pic.data[pos+2]=col.b;
	pic.data[pos+3]=col.a;
}
  
  
  /*
 function line(x0, y0, x1, y1)
   dx := abs(x1-x0)
   dy := abs(y1-y0) 
   if x0 < x1 then sx := 1 else sx := -1
   if y0 < y1 then sy := 1 else sy := -1
   err := dx-dy
 
   loop
     plot(x0,y0)
     if x0 = x1 and y0 = y1 exit loop
     e2 := 2*err
     if e2 > -dy then 
       err := err - dy
       x0 := x0 + sx
     end if
     if e2 < dx then 
       err := err + dx
       y0 := y0 + sy 
     end if
   end loop
   */
//currpos=(Math.floor(mouseY/zoomv)*spw+Math.floor(mouseX/zoomv))*4;
  function drawdataline(hova,pixcol,lmx,lmy,mx,my){ //kimásolja a frame-t, datát módosít, visszamásol 
	dx = Math.abs(mx-lmx);
	dy = Math.abs(my-lmy);
	sx = lmx < mx ?  1 : -1;
	sy = lmy < my ?  1 : -1;
	err = dx-dy;
   
	do{ currpos=(Math.floor(lmy/zoomv)*spw+Math.floor(lmx/zoomv))*4;
  		hova.data[currpos  ]=pixcol.r;
		hova.data[currpos+1]=pixcol.g;
		hova.data[currpos+2]=pixcol.b;
		hova.data[currpos+3]=255;
		
		e2= 2*err;
		if(e2 > -dy){ err = err - dy; lmx += sx}
        if(e2 < dx){ err = err + dx; lmy+= sy }

		}while(lmx!=mx || lmy!=my);
  };
  
   function drawdataline2(hova,pix,lmx,lmy,mx,my){ /*érdemesebb lenne kész x y poz-t adni?*/
	dx = Math.abs(mx-lmx);
	dy = Math.abs(my-lmy);
	sx = lmx < mx ?  1 : -1;
	sy = lmy < my ?  1 : -1;
	err = dx-dy;
   
	do{ /*currpos=(Math.floor(lmy/zoomv)*spw+Math.floor(lmx/zoomv))*4;
  		hova.data[currpos  ]=col.r;
		hova.data[currpos+1]=col.g;
		hova.data[currpos+2]=col.b;
		hova.data[currpos+3]=255;*/
		hova.putImageData(pix,Math.floor(lmx/zoomv),Math.floor(lmy/zoomv));
		 
		e2= 2*err;
		if(e2 > -dy){ err = err - dy; lmx += sx}
        if(e2 < dx){ err = err + dx; lmy+= sy }

		}while(lmx!=mx || lmy!=my);
  };
  
    function skewHor(hova,pix,posx,posy,step,selectchange){
	var curx=0;
	var cury=0;
	var skewed=hova.createImageData(pix.width+Math.ceil(Math.abs(step*pix.height)),pix.height);
    var offset=skewed.width-pix.width;
	do{ 
		 for(var i=0;i<pix.width*4;i++)
		   {   if(step>=0)skewed.data[cury*skewed.width*4 + i + Math.floor(curx)*4]=pix.data[cury*pix.width*4 + i]
		             else skewed.data[cury*(skewed.width)*4 + i  + (offset+Math.ceil(curx))*4]=pix.data[cury*pix.width*4 + i]} 
		   curx+=step; cury++;
		
		}while(cury<pix.height);
		
		if(step>=0) {hova.putImageData(skewed,posx,posy);        selectchange.selx=posx;}
		else        {hova.putImageData(skewed,posx-offset,posy); selectchange.selx=posx-offset;}
																 selectchange.sely=posy; selectchange.buff=skewed;
  }; 
  
   function skewVer(hova,pix,posx,posy,step,selectchange){
	var curx=0;  var cury=0;
	var skewed=hova.createImageData(pix.width, pix.height +Math.ceil(Math.abs(step*pix.width)));
    var offset=skewed.height-pix.height;
	do{ 
		 for(var i=0;i<pix.height;i++)
		   {   if(step>=0)
				for(var ii=0;ii<4;ii++) /*rgba loop*/
				skewed.data[(i+ Math.floor(cury))*pix.width*4  +curx*4 +ii]=pix.data[i*pix.width*4 +curx*4 +ii]  
		       else 
				for(var ii=0;ii<4;ii++) 
				skewed.data[(i+ Math.floor(cury)+offset)*pix.width*4  +curx*4 +ii]=pix.data[i*pix.width*4 +curx*4 +ii]  
			   
			   //skewed.data[cury*(skewed.width)*4 + i  + (offset+Math.ceil(curx))*4]=pix.data[cury*pix.width*4 + i]
					 } 
		   cury+=step; curx++;
		
		}while(curx<pix.width);
		
		if(step>=0) {hova.putImageData(skewed,posx,posy);        selectchange.sely=posy;}
		else        {hova.putImageData(skewed,posx,posy-offset); selectchange.sely=posy-offset;}
																 selectchange.selx=posx; selectchange.buff=skewed;
  };
  
  
  
  
  function sleep(millis, callback) {setTimeout(function(){ callback(); }, millis);}
  
  
  var colWhite={r:255, g:255, b:255, a:255};
  /*scanline fill?*/
  function floodFill(base,temp,px,py,mit,mire){ //original ifalpha-layer
	var pos=(px+py*spw)*4;
	
	var stax=new Array();
	if(matchCol(mit,mire))return;
	var node={x:px,y:py};
	stax.push(node);
	do{
		node=stax.pop();
		if(matchCol(getCol(base,node.x,node.y),mit)){
				setCol32(base,node.x,node.y,mire); if(temp!=null) setCol32(temp,node.x,node.y,colWhite); 
				stax.push({x:node.x+1,y:node.y});
				stax.push({x:node.x-1,y:node.y});
				stax.push({x:node.x,y:node.y+1});
				stax.push({x:node.x,y:node.y-1}); 
			}
		}while(stax.length>0)
	return;
  }
  function floodFilldouble(base,temp,px,py,mit,mit2,mire){ 
	var pos=(px+py*spw)*4;
	var stax=new Array();
	if(matchCol(mit,mire))return;
	var node={x:px,y:py};
	stax.push(node);
	do{
		node=stax.pop();
		if(matchCol(getCol(base,node.x,node.y),mit)||matchCol(getCol(base,node.x,node.y),mit2)){
				setCol32(base,node.x,node.y,mire); if(temp!=null) setCol32(temp,node.x,node.y,colWhite); 
				stax.push({x:node.x+1,y:node.y});
				stax.push({x:node.x-1,y:node.y});
				stax.push({x:node.x,y:node.y+1});
				stax.push({x:node.x,y:node.y-1}); 
			}
		}while(stax.length>0)
	return;
  }
  
  

  var tools = {}; 

 tools.pencil = function () {
    var tool = this;
    this.started = false;
	this.alternative = false; //colorpick
	this.tracknum = 0;
	this.drawbuff =null;


    function drawstart (e) { //e.preventDefault(); /*prevent touchscreen autoscroll*/
	mouseX=(e.clientX + $(document).scrollLeft() - $(overc).offset().left);
	mouseY=(e.clientY + $(document).scrollTop() - $(overc).offset().top);

		
	 
        tool.started = true;
		tool.tracknum = 0;
	 if(!ctrlOn){ //if ctrl then colorpick on move
		overctx.clearRect(0,0,spw*zoomv,sph*zoomv);
		//tool.drawbuff = aw.realctx.getImageData( 50*currentframe, 0,  spw,sph);
		
		tempctx.clearRect(0,0,spw,sph);	
		lastmX=mouseX;
		lastmY=mouseY;
	  }
	  else /*ctrl*/ {tool.alternative=true;}

    };
	this.touchstart = drawstart;
	this.mousedown = drawstart; 


    function drawmove (e) {  //e.preventDefault(); 
	mouseX=(e.clientX + $(document).scrollLeft() - $(overc).offset().left);
	mouseY=(e.clientY + $(document).scrollTop() - $(overc).offset().top);
	

	
      if (tool.started && !tool.alternative) {
      //  aw.realctx.lineTo(mouseX, mouseY);
       // aw.realctx.stroke();
	   
		tool.tracknum++;
		
		//drawdataline(tool.drawbuff,lastmX,lastmY,mouseX,mouseY);
		
		
		
		if(e.button==0)drawdataline2(tempctx,drawpixel,lastmX,lastmY,mouseX,mouseY);
		if(e.button==2)drawdataline2(tempctx,erasepixel,lastmX,lastmY,mouseX,mouseY);
		//trace(e.button);
		
	//document.getElementById("debugp").innerHTML=mouseX.toString();
	//	aw.realctx.putImageData(tool.drawbuff,50*currentframe, 0,Math.min(lastmX,mouseX)/zoomv,Math.min(lastmY,mouseY)/zoomv,Math.abs(lastmX-mouseX)/zoomv,Math.abs(lastmY-mouseY)/zoomv);	//alert(Math.min(lastmY,mouseY)-1)
		//kell aw.realctx.putImageData(tool.drawbuff,50*currentframe, 0);	
		 if(e.button==2) ctx.globalCompositeOperation="destination-out";
		 else ctx.globalCompositeOperation="source-over";
		 applytemp();
		 ctx.globalCompositeOperation="source-over";
		 //setcurrentframe(currentframe);
		lastmX=mouseX;
		lastmY=mouseY;

      }
	  else /*no toolstarted*/
	  {		overctx.clearRect(0,0,spw*zoomv,sph*zoomv);
			overctx.beginPath();
			if(overctx.setLineDash)overctx.setLineDash([0]);
			selx=Math.floor(mouseX/zoomv);
			sely=Math.floor(mouseY/zoomv);
			overctx.rect(selx*zoomv,  sely*zoomv,  zoomv,  zoomv);
			overctx.stroke();
	  }
	  if(tool.started && tool.alternative){
				var p = aw.realctx.getImageData(Math.floor(mouseX/zoomv)+spw*currentframe, Math.floor(mouseY/zoomv), 1, 1).data; 
				//colorpick(rgbToHex(p[0],p[1],p[2]));  
				if(e.button!=2)colorpickchange({m:{r:p[0],g:p[1],b:p[2]}});
							   colorpickaltchange({m:{r:p[0],g:p[1],b:p[2]}});  }
    };
	this.touchmove = drawmove;
	this.mousemove = drawmove;

    function drawend (e) {//  e.preventDefault(); 
	mouseX=(e.clientX + $(document).scrollLeft() - $(overc).offset().left);
	mouseY=(e.clientY + $(document).scrollTop() - $(overc).offset().top);
      if (tool.started) {
        tool.mousemove(e);
		if(!tool.alternative){
			   if(e.button==2) aw.realctx.globalCompositeOperation="destination-out";
			   else aw.realctx.globalCompositeOperation="source-over";
			commitTemp();
			aw.realctx.globalCompositeOperation="source-over";
		}
		else {tool.alternative=false;}
        tool.started = false;
      }
    };
	this.touchend = drawend;
	this.mouseup = drawend;
	//this.mouseout = function (e) { if (tool.started) {tool.mouseup(e);}}
  };

  
  var vanselect=false;
  var softselect=false;
  var movebuff;
  var localClipboard;
tools.rectselect = function () {
    var tool = this;
    this.started = false; //here:selection scaling in progress
	this.alternative = false; //skew
	dragstarted=false;
	var skewXbott=0; var skewYleft=0; var skewYright=0; var skewXtop=0;
	var selchange=new Object(); //for changing movebuff after skew

    this.mousedown = function (e) {
	mouseX=(e.clientX - $(document).scrollLeft() - $(overc).offset().left);
	mouseY=(e.clientY - $(document).scrollTop() - $(overc).offset().top);
	
	
	if(vanselect && (mouseX/zoomv>selx)&&(mouseX/zoomv<selx+selw) && (mouseY/zoomv>sely)&&(mouseY/zoomv<sely+selh) )
	{if(!ctrlOn){
		if(!softselect){
			
			//movebuff = aw.realctx.getImageData(selx+currentframe*spw,sely,selw,selh);
			aw.realctx.clearRect(selx+spw*currentframe,sely,selw,selh);
			tempctx.clearRect(0,0,spw,sph);			
			tempctx.putImageData(movebuff,selx,sely);
			setcurrentframe(currentframe); applytemp();
			
			

		}
		
		
		startselx=selx; startsely=sely;
		dragstarted=true; softselect=true;
	 }else /*ctrl*/ {tool.alternative=true; startselx=selx; startsely=sely;}
	}
        else{tool.started = true; commitTemp();}
		startmX=mouseX;
		startmY=mouseY;
	
    };


    this.mousemove = function (e) {
	mouseX=(e.clientX - $(document).scrollLeft() - $(overc).offset().left);
	mouseY=(e.clientY - $(document).scrollTop() - $(overc).offset().top);
	
	if(vanselect && ctrlOn && !tool.started && !dragstarted &&!tool.alternative ) //skew hover
	{skewXbott=skewYright=skewYleft=skewXtop=0;
	  if((mouseX/zoomv>selx)&&(mouseX/zoomv<selx+selw) && (mouseY/zoomv>sely)&&(mouseY/zoomv<sely+selh))
		{mXrat=(mouseX/zoomv-selx)/selw; mYrat=(mouseY/zoomv-sely)/selh; mYrat2=1-((mouseY/zoomv-sely)/selh);
		
			 if(mXrat<mYrat && mYrat2<mXrat)  {/*bott*/ skewXbott=1;  document.getElementById('drawoverlay').style.cursor="ew-resize"; }
		else if(mXrat<mYrat && mYrat2>=mXrat) {/*left*/ skewYleft=1;  document.getElementById('drawoverlay').style.cursor="ns-resize"; }
		else if(mXrat>=mYrat && mYrat2<mXrat) {/*right*/skewYright=1; document.getElementById('drawoverlay').style.cursor="ns-resize"; }
		else 							      {/*top*/  skewXtop=1;   document.getElementById('drawoverlay').style.cursor="ew-resize"; }
		} else {document.getElementById('drawoverlay').style.cursor="url(curpencil.cur),pointer";}
	} else
	
	
	if(tool.alternative)
	{tempctx.clearRect(0,0,spw,sph); 
	  
	  //tempctx.putImageData(movebuff,selx,sely); 
			if(!softselect){aw.realctx.clearRect(selx+spw*currentframe,sely,selw,selh);setcurrentframe(currentframe); applytemp();softselect=true;}
			
			selx=startselx+Math.ceil((mouseX-startmX)/zoomv); sely=startsely+Math.ceil((mouseY-startmY)/zoomv);
			
	       if(skewXbott==1) skewHor(tempctx,movebuff, startselx,startsely  ,((selx-startselx)/selw)*selw/selh ,selchange);
	   else if(skewXtop==1)  skewHor(tempctx,movebuff, selx,startsely  , -((selx-startselx)/selw)*selw/selh ,selchange);
	   else if(skewYleft==1)  skewVer(tempctx,movebuff, startselx,sely  , -((sely-startsely)/selh)*selh/selw ,selchange);
	   else if(skewYright==1)  skewVer(tempctx,movebuff, startselx,startsely  , ((sely-startsely)/selh)*selh/selw ,selchange);
	 
	  setcurrentframe(currentframe);
	  applytemp();
	  
	  //selx=startselx+Math.ceil((mouseX-startmX)/zoomv); sely=startsely+Math.ceil((mouseY-startmY)/zoomv);
	  
	 
	  
	  
	  
	  overctx.clearRect(0,0,spw*zoomv,sph*zoomv);
	  overctx.beginPath();
	  //overctx.setTransform(1,0.5,0,1,0,0);
	  overctx.moveTo(startselx*zoomv  		    + ((selx-startselx)*zoomv)*skewXtop,  startsely*zoomv				+  ((sely-startsely)*zoomv)*skewYleft);
	  overctx.lineTo(startselx*zoomv+selw*zoomv + ((selx-startselx)*zoomv)*skewXtop,  startsely*zoomv				+  ((sely-startsely)*zoomv)*skewYright);
      overctx.lineTo(startselx*zoomv+selw*zoomv + ((selx-startselx)*zoomv)*skewXbott, startsely*zoomv+selh*zoomv	+  ((sely-startsely)*zoomv)*skewYright);
	  overctx.lineTo(startselx*zoomv			+ ((selx-startselx)*zoomv)*skewXbott, startsely*zoomv+selh*zoomv	+  ((sely-startsely)*zoomv)*skewYleft);
	  overctx.lineTo(startselx*zoomv 	 		+ ((selx-startselx)*zoomv)*skewXtop,  startsely*zoomv				+  ((sely-startsely)*zoomv)*skewYleft);
	  //overctx.setTransform(1,0,0,1,0,0);
	  overctx.stroke();}
	  
	  
	else
	{
	if(vanselect && (mouseX/zoomv>selx)&&(mouseX/zoomv<selx+selw) && (mouseY/zoomv>sely)&&(mouseY/zoomv<sely+selh) )
		    {document.getElementById('drawoverlay').style.cursor="move"}
		else{document.getElementById('drawoverlay').style.cursor="url(curpencil.cur),pointer";}
	  if(dragstarted){tempctx.clearRect(0,0,spw,sph);
	  selx=startselx+Math.ceil((mouseX-startmX)/zoomv); sely=startsely+Math.ceil((mouseY-startmY)/zoomv);
	  tempctx.putImageData(movebuff,selx,sely); 
	  setcurrentframe(currentframe);
	  applytemp();}
	  
	 
	  
      if (tool.started || dragstarted  ) {
		//showrect(,,,,)
		
		overctx.clearRect(0,0,spw*zoomv,sph*zoomv);
				    overctx.beginPath();
        overctx.setLineDash([5,2]);
		if(!dragstarted ){
			if(startmX<mouseX){selx=Math.floor(startmX/zoomv); selw=Math.ceil((mouseX-startmX)/zoomv)} else {selx=Math.ceil(startmX/zoomv); selw=Math.floor((mouseX-startmX)/zoomv)}
			if(startmY<mouseY){sely=Math.floor(startmY/zoomv); selh=Math.ceil((mouseY-startmY)/zoomv)} else {sely=Math.ceil(startmY/zoomv); selh=Math.floor((mouseY-startmY)/zoomv)}
			overctx.rect(selx*zoomv,  sely*zoomv,  selw*zoomv,  selh*zoomv);
		}else{
			overctx.rect(selx*zoomv,  sely*zoomv,  selw*zoomv,  selh*zoomv);}
		
    overctx.stroke();
      }
	   }//normal
	  
    };

    this.mouseup = function (e) {
	mouseX=(e.clientX - $(document).scrollLeft() - $(overc).offset().left);
	mouseY=(e.clientY - $(document).scrollTop() - $(overc).offset().top);
	 
	  
	 
	  
      if (tool.started) {
	    if(!dragstarted && selw!=0 && selh!=0)
			{movebuff = aw.realctx.getImageData(selx+currentframe*spw,sely,selw,selh);
			}
	  
        tool.mousemove(e);
        tool.started = false;
		temp1=Math.min(selx,selx+selw); temp2=Math.max(selx,selx+selw);
		selx=temp1; selw=temp2-temp1;
		temp1=Math.min(sely,sely+selh); temp2=Math.max(sely,sely+selh);
		sely=temp1; selh=temp2-temp1;
		
			//hangyák: overctx.lineDashOffset = 2;
		//cutrect
		//aw.realctx.fillRect(selx+spw*currentframe,sely,selw,selh); setcurrentframe(currentframe);
		vanselect=(selw!=0 && selh!=0);
      }
	  if(dragstarted){dragstarted=false;}
	   
	   if(tool.alternative){tool.alternative=false;  movebuff=selchange.buff;
		selx=selchange.selx; sely=selchange.sely;  selw=movebuff.width; selh=movebuff.height; 
		overctx.clearRect(0,0,spw*zoomv,sph*zoomv);
		overctx.beginPath(); overctx.setLineDash([5,2]);
		overctx.rect(selx*zoomv,  sely*zoomv,  selw*zoomv,  selh*zoomv); overctx.stroke();
		}
    };
	//this.mouseout = function (e) { if (tool.started) {tool.mouseup(e);}}
  };


  
tools.fill = function () {
    var tool = this;
	this.drawbuff =null;

    this.mousedown = function (e) {
	mouseX=(e.clientX + $(document).scrollLeft() - $(overc).offset().left);
	mouseY=(e.clientY + $(document).scrollTop() - $(overc).offset().top);
		tempctx.clearRect(0,0,spw,sph);
		tool.drawbuff = aw.realctx.getImageData( spw*currentframe, 0,  spw,sph);
		var startCol=getCol(tool.drawbuff, Math.floor(mouseX/zoomv), Math.floor(mouseY/zoomv));
		
		if(e.button==2){//deletefill
		var alphaData= aw.realctx.createImageData(spw,sph);
		var colalph={r:0, g:0, b:0, a:0};
		floodFill(tool.drawbuff,alphaData, Math.floor(mouseX/zoomv),Math.floor(mouseY/zoomv),startCol,colalph);
		tempctx.putImageData(alphaData,0,0); 
		aw.realctx.globalCompositeOperation="destination-out";
		commitTemp();
		aw.realctx.globalCompositeOperation="source-over";
		}
		
		else{
		var colalph={r:col.r, g:col.g, b:col.b, a:255};
		floodFill(tool.drawbuff,null, Math.floor(mouseX/zoomv),Math.floor(mouseY/zoomv),startCol,colalph); 
		tempctx.putImageData(tool.drawbuff,0,0);
		commitTemp();
		
		}

		setcurrentframe(currentframe);

    };


    this.mousemove = function (e) {;};
    this.mouseup = function (e) {;};
	
 };
 
tools.outlinefill = function () { //bug:not working on white
    var tool = this;
	this.drawbuff =null;
	var drawbuff2=null;

    this.mousedown = function (e) {
	mouseX=(e.clientX + $(document).scrollLeft() - $(overc).offset().left);
	mouseY=(e.clientY + $(document).scrollTop() - $(overc).offset().top);
		tempctx.clearRect(0,0,spw,sph);
		tool.drawbuff = aw.realctx.getImageData( spw*currentframe, 0,  spw,sph);
		var startCol=getCol(tool.drawbuff, Math.floor(mouseX/zoomv), Math.floor(mouseY/zoomv)); var startCol2=null;
		for(var i=0;i<colorList.length;i++)
		 if(colorList[i].a!=null) { if( matchCol(startCol,colorList[i].m)) {startCol2=colorList[i].a; break;} 
							   else if( matchCol(startCol,colorList[i].a)) {startCol2=colorList[i].m; break;}   }
		
		var colalph={r:255,g:255,b:255,a:255};//{r:col.r, g:col.g, b:col.b, a:255};
		 drawbuff2= aw.realctx.createImageData(spw,sph);
		 if(startCol2==null)
		 floodFill(tool.drawbuff, drawbuff2, Math.floor(mouseX/zoomv),Math.floor(mouseY/zoomv),startCol,colalph);
		 else
		floodFilldouble(tool.drawbuff, drawbuff2, Math.floor(mouseX/zoomv),Math.floor(mouseY/zoomv),startCol,startCol2,colalph);
	
	/*outline part*/
	tool.drawbuff= aw.realctx.createImageData(spw,sph);
	if(e.button==2){//inward outline
		for(var i=0; i<tool.drawbuff.data.length/4; i++)
		{if(drawbuff2.data[i*4+3]!=0 && 
			((drawbuff2.data[i*4-4+3]==0 && i%spw>0)
		|| (drawbuff2.data[i*4+4+3]==0 && i%spw<spw-1)
		|| (drawbuff2.data[(i*4)-(spw*4)+3]==0 && i>spw) 
		|| (drawbuff2.data[(i*4)+(spw*4)+3]==0 && i<tool.drawbuff.data.length/4-spw)  
		) 
		) tool.drawbuff.data[i*4+3]=255;}
	}
	else{ //outline
		for(var i=0; i<tool.drawbuff.data.length/4; i++)
		{if(drawbuff2.data[i*4+3]==0 && 
			((drawbuff2.data[i*4-4+3]!=0 && i%spw>0)
		|| (drawbuff2.data[i*4+4+3]!=0 && i%spw<spw-1)
		|| (drawbuff2.data[(i*4)-(spw*4)+3]!=0 && i>spw) 
		|| (drawbuff2.data[(i*4)+(spw*4)+3]!=0 && i<tool.drawbuff.data.length/4-spw)  
		) 
		) tool.drawbuff.data[i*4+3]=255;}
	}
	tempctx.putImageData(tool.drawbuff,0,0);
	commitTemp();
	setcurrentframe(currentframe);
    };

    this.mousemove = function (e) {;};
    this.mouseup = function (e) {;};

 };
  
  
  
tools.shading = function () {
    var tool = this;
    this.started = false;
	this.drawbuff =null;
	var shadeCol=null;
	var shadepixel = tempctx.createImageData(1,1);

    function drawstart (e) { 
	mouseX=(e.clientX + $(document).scrollLeft() - $(overc).offset().left);
	mouseY=(e.clientY + $(document).scrollTop() - $(overc).offset().top);

	
	tool.drawbuff = aw.realctx.getImageData( spw*currentframe, 0,  spw,sph);
	var startCol=getCol(tool.drawbuff, Math.floor(mouseX/zoomv), Math.floor(mouseY/zoomv));
	var i;
	for( i=0;i<colorList.length;i++)
		{if(colorList[i].a!=null && ( matchCol(startCol,colorList[i].m) || matchCol(startCol,colorList[i].a) )) {break;}      
		}
	
		if(i<18){
         tool.started = true;
		 if(e.button==2) shadeCol=colorList[i].m;
		 else			 shadeCol=colorList[i].a;
		 shadepixel.data[0]=shadeCol.r;  shadepixel.data[1]=shadeCol.g;  shadepixel.data[2]=shadeCol.b;  shadepixel.data[3]=255; 
		 dumpc.w=aw.spw; dumpc.h=aw.sph; dumpctx.clearRect(0,0,spw,sph);

		 for(var p=0;p<tool.drawbuff.data.length/4;p++)
			{if(!matchCol({r:tool.drawbuff.data[p*4],g:tool.drawbuff.data[p*4+1],b:tool.drawbuff.data[p*4+2]},colorList[i].m) && 
			!matchCol({r:tool.drawbuff.data[p*4],g:tool.drawbuff.data[p*4+1],b:tool.drawbuff.data[p*4+2]},colorList[i].a) )
			   {tool.drawbuff.data[p*4]=0;tool.drawbuff.data[p*4+1]=0;tool.drawbuff.data[p*4+2]=0;tool.drawbuff.data[p*4+3]=0;}}
		 
		 overctx.clearRect(0,0,spw*zoomv,sph*zoomv);
		 tempctx.clearRect(0,0,spw,sph);
		 tempctx.putImageData(tool.drawbuff,0,0);
		}
		//tool.drawbuff = aw.realctx.getImageData( 50*currentframe, 0,  spw,sph);
		
		//tempctx.clearRect(0,0,spw,sph);	
		lastmX=mouseX;
		lastmY=mouseY;
    };
	this.touchstart = drawstart;
	this.mousedown = drawstart; 


    function drawmove (e) {  
	mouseX=(e.clientX + $(document).scrollLeft() - $(overc).offset().left);
	mouseY=(e.clientY + $(document).scrollTop() - $(overc).offset().top);
	

	
      if (tool.started ) {
	 
		drawdataline2(dumpctx,shadepixel,lastmX,lastmY,mouseX,mouseY);
	  

		//trace(e.button);
		
	//document.getElementById("debugp").innerHTML=mouseX.toString();
	//	aw.realctx.putImageData(tool.drawbuff,50*currentframe, 0,Math.min(lastmX,mouseX)/zoomv,Math.min(lastmY,mouseY)/zoomv,Math.abs(lastmX-mouseX)/zoomv,Math.abs(lastmY-mouseY)/zoomv);	//alert(Math.min(lastmY,mouseY)-1)
		//kell aw.realctx.putImageData(tool.drawbuff,50*currentframe, 0);	
		//  tempctx.globalCompositeOperation="source-atop";
		  //tempctx.putImageData(tool.drawbuff,0,0);
		  tempctx.globalCompositeOperation="source-atop";
		    tempctx.drawImage(dumpc, 0, 0);
		  tempctx.globalCompositeOperation="source-over";
		 applytemp();
		 
		 //setcurrentframe(currentframe);
		lastmX=mouseX;
		lastmY=mouseY;

      }
	  else /*no toolstarted*/
	  {		overctx.clearRect(0,0,spw*zoomv,sph*zoomv);
			overctx.beginPath();
			overctx.setLineDash([0]);
			selx=Math.floor(mouseX/zoomv);
			sely=Math.floor(mouseY/zoomv);
			overctx.rect(selx*zoomv,  sely*zoomv,  zoomv,  zoomv);
			overctx.stroke();
	  }
    };
	this.touchmove = drawmove;
	this.mousemove = drawmove;

    function drawend (e) {//  e.preventDefault(); 
	mouseX=(e.clientX + $(document).scrollLeft() - $(overc).offset().left);
	mouseY=(e.clientY + $(document).scrollTop() - $(overc).offset().top);
      if (tool.started) {
        tool.mousemove(e);
		
			    aw.realctx.globalCompositeOperation="source-atop";
			  
			commitTemp();
			aw.realctx.globalCompositeOperation="source-over";
		

        tool.started = false;
      }
    };
	this.touchend = drawend;
	this.mouseup = drawend;
	//this.mouseout = function (e) { if (tool.started) {tool.mouseup(e);}}
};
  
  
  
var tool=new tools['pencil'];



function outline(){
	tempctx.clearRect(0,0,spw,sph);	
	var samplebuff = aw.realctx.getImageData( spw*currentframe, 0,  spw,sph);
	var drawbuff = aw.realctx.getImageData( spw*currentframe, 0,  spw,sph);

	for(var i=0; i<drawbuff.data.length/4; i++)
	{if(drawbuff.data[i*4+3]==0 && 
	    ((samplebuff.data[i*4-4+3]!=0 && i%spw>0)
	  || (samplebuff.data[i*4+4+3]!=0 && i%spw<spw-1)
	  || (samplebuff.data[(i*4)-(spw*4)+3]!=0 && i>spw) 
	  || (samplebuff.data[(i*4)+(spw*4)+3]!=0 && i<drawbuff.data.length/4-spw)  
	  //stick-brawler specials:
	  //|| (samplebuff.data[i*4+8+3]!=0 && i%spw<spw-2)
	  //|| (samplebuff.data[(i*4)-(spw*8)+3]!=0 && i>spw*2) 
	  //|| (samplebuff.data[(i*4)-(spw*4)+4 +3]!=0 && i>spw && i%spw<spw-1)
	  ) 
	  ) drawbuff.data[i*4+3]=255;}
	
	tempctx.putImageData(drawbuff,0,0);
	commitTemp();
	setcurrentframe(currentframe);
}








function undoHandler() {
 
 if(undobuff.length > 0){
	var undorec = undobuff.pop();
	//set active window to undorec.windowId
	currentframe=undorec.frame;
	
	var redorec={windowId:undorec.windowId,
			frame:undorec.frame,
			data:aw.realctx.getImageData( spw*currentframe, 0,  spw,sph) };
	
	aw.realctx.putImageData(undorec.data,currentframe*spw,0);
	setcurrentframe(currentframe);
	redobuff.push(redorec);
	tempctx.clearRect(0,0,aw.spw,aw.sph);	
 }
 }
 
function redoHandler() {
  if(redobuff.length > 0){
	var redorec = redobuff.pop();
	//set active window to redorec.windowId
	currentframe=redorec.frame
	
	var undorec={windowId:redorec.windowId,
			frame:redorec.frame,
			data:aw.realctx.getImageData( spw*currentframe, 0,  spw,sph) };
	
	aw.realctx.putImageData(redorec.data,currentframe*spw,0);
	setcurrentframe(currentframe);
	undobuff.push(undorec);
	tempctx.clearRect(0,0,aw.spw,aw.sph);	
 }
 }
 
function exportHandler() {
	//var savedimage = aw.realc.toDataURL("image/png").replace("image/png", "image/octet-stream");  // if you dont replace you will get a DOM 18 exception.
	//window.location.href=savedimage;
	//savestart(document.getElementById("downloadTrigger"))
	document.getElementById('downloadTrigger').click();
	return false;
 }
 
function exportstart(e)
	{e.href=aw.realc.toDataURL("image/png").replace("image/png", "image/octet-stream");
	e.download=aw.name+".png"; /*callback needed?*/
 }


function importHandler() { //var r=confirm("szöveg"); if(r)...
	document.getElementById('uploadimage').click();
 }
function filepick(e){ //for import
	//set aw.realctx()
	var img=new Image();
	f = document.getElementById("uploadimage").files[0],
        url = window.URL || window.webkitURL,
        src = url.createObjectURL(f);

    img.src = src;
	img.onload = function() {
	aw.realc.width=img.width;
	aw.realctx.drawImage(img, 0, 0 , img.width,img.height);
	}
}

function saveHandler() {
	document.getElementById('saveTrigger').click();
	return false;
}
function savestart(e) {
	// create the blob object storing the data to compress
	var blob2 = new Blob([ "Lorem ipsum dolor sit amet, consectetuer adipiscing elit..." ], {
	type : "text/plain"
	});
	var img=new Image();
	
	var blob = aw.realc.toDataURL("image/png");
	
	// creates a zip storing the file "lorem.txt" with blob as data
	// the zip will be stored into a Blob object (zippedBlob)
	var URLObj = window.URL || window.webkitURL;
	
	zipBlob("lorem.png", blob, function(zippedBlob) {
	 e.href=URLObj.createObjectURL(zippedBlob);
	e.download=aw.name+".zip";
	});

	function zipBlob(filename, blob, callback) {
	// use a zip.BlobWriter object to write zipped data into a Blob object
	zip.createWriter(new zip.BlobWriter("application/zip"), function(zipWriter) {
		// use a BlobReader object to read the data stored into blob variable
		zipWriter.add(filename, new zip.Data64URIReader(blob), function() {
		// close the writer and calls callback function
		zipWriter.close(callback);
		});
	}, onerror);
	}
	
	
	/*function zipBlob(filename, blob, callback) {
	// use a zip.BlobWriter object to write zipped data into a Blob object
	zip.createWriter(new zip.BlobWriter("application/zip"), function(zipWriter) {
		// use a BlobReader object to read the data stored into blob variable
		zipWriter.add(filename, new zip.BlobReader(blob), function() {
		// close the writer and calls callback function
		zipWriter.close(callback);
		});
	}, onerror);
	}*/



	function onerror(message) {console.error(message);}
}

function openHandler() {alert("open");}


function keyPress(e) { //e.preventDefault(); e.stopPropagation();
      var evtobj = window.event? event : e
      if (evtobj.keyCode == 90 && evtobj.ctrlKey) undoHandler(); //ctrl z
	  if (evtobj.keyCode == 32 && evtobj.ctrlKey) undoHandler(); //ctrl space	  
	  if (evtobj.keyCode == 89 && evtobj.ctrlKey) redoHandler(); //ctrl y
	  if (evtobj.keyCode == 83 && evtobj.ctrlKey) saveHandler(); //ctrl s
	  if (evtobj.keyCode == 79 && evtobj.ctrlKey) openHandler(); //ctrl o
	  if (evtobj.keyCode == 69 && evtobj.ctrlKey) exportHandler(); //ctrl e
	  if (evtobj.keyCode == 73 && evtobj.ctrlKey) importHandler(); //ctrl i	  
	  if (evtobj.keyCode == 86 && !evtobj.ctrlKey) localPasteHandler(); //ctrl v 	  
	  if (evtobj.keyCode == 67 && !evtobj.ctrlKey) localCopyHandler(); //ctrl c 	
	  if (evtobj.keyCode == 37 )setcurrentframe(--currentframe) ; //left
	  if (evtobj.keyCode == 39 )setcurrentframe(++currentframe) ; //right
	  if (evtobj.keyCode == 13 ) animate(); //enter
	  shiftOn = evtobj.shiftKey ? true : false;
	  ctrlOn =  evtobj.ctrlKey  ? true : false;
}

window.onkeydown = keyPress;

//disabling auto ctrl s/o  -disabling at keyDOWN  + disabling every other browser-shortcuts like refresh, close etc. 
window.addEventListener("keydown", function(e) {
  //if ( /*((e.keyCode == 79)||(e.keyCode == 83)) &&*/ /*e.ctrlKey*/ true ) {
 // e.preventDefault(); e.stopPropagation(); return false;// }
	}, false);

window.addEventListener("keyup", function(e) {var evtobj = window.event? event : e
				//e.preventDefault();e.stopPropagation(); 
				shiftOn = evtobj.shiftKey ? true : false; 
				ctrlOn =  evtobj.ctrlKey  ? true : false; 
			},false);
window.addEventListener("paste", clipboardPasteHandler);
	


//=== Clipboard ================================================================

//firefox
/*
var pasteCatcher;
if (!window.Clipboard){
	pasteCatcher = document.createElement("div");
	pasteCatcher.setAttribute("id", "paste_ff");
	pasteCatcher.setAttribute("contenteditable", "");
	pasteCatcher.style.cssText = 'opacity:0;position:fixed;top:0px;left:0px;';
	pasteCatcher.style.marginLeft = "-20px";
	document.body.appendChild(pasteCatcher);
	pasteCatcher.focus();
	document.addEventListener("click", function(){
		//pasteCatcher.focus();
		});
	document.getElementById('paste_ff').addEventListener('DOMSubtreeModified',function(){
		if(pasteCatcher.children.length == 1){
			img = pasteCatcher.firstElementChild.src;
            
            var img2 = new Image();
            img2.onload = function(){
                ctx.drawImage(img2, 0, 0);
                }
            img2.src = img;
            //ctx.drawImage(img, 0, 0);
         
            
            //ctx.drawImage(img, 0, 0);
			pasteCatcher.innerHTML = '';
			}
		},false);
	}
//chrome
window.addEventListener("paste", pasteHandler);
function pasteHandler(e){
	if(e.clipboardData) {
		var items = e.clipboardData.items;
		if (items){
			for (var i = 0; i < items.length; i++) {
				if (items[i].type.indexOf("image") !== -1) {
					var blob = items[i].getAsFile();
					var URLObj = window.URL || window.webkitURL;
					var source = URLObj.createObjectURL(blob);
					paste_createImage(source);
					}
				}
			}
		// If we can't handle clipboard data directly (Firefox),
		// we need to read what was pasted from the contenteditable element
		else{
			}
		}
	else{
		setTimeout(paste_check_Input, 1);
		}
	}
function paste_check_Input(){
	var child = pasteCatcher.childNodes[0];
	pasteCatcher.innerHTML = "";
	if (child){
		if (cild.tagName === "IMG"){
			paste_createImage(child.src);
			}
		}
	}
function paste_createImage(source){
	var pastedImage = new Image();
	pastedImage.onload = function() {
        aw.realctx.drawImage(pastedImage, 0, 0);
		}
	pastedImage.src = source;
	}
	
*/	

/*VERZIÓ 2*/

if (!window.Clipboard) {
   var pasteCatcher = document.createElement("div");
    
   // Firefox allows images to be pasted into contenteditable elements
   pasteCatcher.setAttribute("contenteditable", "");
    
   // We can hide the element and append it to the body,
   pasteCatcher.style.opacity = 0;
   //!!!!!!!document.body.appendChild(pasteCatcher);
 
   // as long as we make sure it is always in focus
   pasteCatcher.focus();
   document.addEventListener("click", function() { pasteCatcher.focus(); });
} 
// Add the paste event listener
/*event*/ // replaced:  window.addEventListener("paste", clipboardPasteHandler);
 
/* Handle paste events */
function clipboardPasteHandler(e) {
   // We need to check if event.clipboardData is supported (Chrome)
 
   if (e.clipboardData) {
      // Get the items from the clipboard
      var items = e.clipboardData.items;
      if (items) { //alert(items[0].type);
         // Loop through all items, looking for any kind of image
         for (var i = 0; i < items.length; i++) {
            if (items[i].type.indexOf("image") !== -1) {
               // We need to represent the image as a file,
               var blob = items[i].getAsFile();
			     // and use a URL or webkitURL (whichever is available to the browser)
               // to create a temporary URL to the object
               var URLObj = window.URL || window.webkitURL;
               var source = URLObj.createObjectURL(blob);
                
               // The URL can then be used as the source of an image
               createImage(source);
            }
         }
      }
   // If we can't handle clipboard data directly (Firefox), 
   // we need to read what was pasted from the contenteditable element
   } else {
      // This is a cheap trick to make sure we read the data
      // AFTER it has been inserted.
      setTimeout(checkInput, 1);
   }
  
}
 
/* Parse the input in the paste catcher element */
function checkInput() {
   // Store the pasted content in a variable
   var child = pasteCatcher.childNodes[0];
 
   // Clear the inner html to make sure we're always
   // getting the latest inserted content
   pasteCatcher.innerHTML = "";
    
   if (child) {
      // If the user pastes an image, the src attribute
      // will represent the image as a base64 encoded string.
      if (child.tagName === "IMG") {
         createImage(child.src);
      }
   }
}
 function createImage(source){
	var pastedImage = new Image();
	pastedImage.onload = function() {
		toolpick('rectselect');
		selx=0;sely=0; selw=dumpc.width = pastedImage.width; selh=dumpc.height = pastedImage.height;
		dumpctx.drawImage(pastedImage,0,0,selw,selh);
		movebuff = dumpctx.getImageData(0,0,selw,selh);
		tempctx.clearRect(0,0,spw,sph);			
		tempctx.putImageData(movebuff,selx,sely);
		setcurrentframe(currentframe); applytemp();
			
		
		startselx=selx; startsely=sely; 
		
			overctx.clearRect(0,0,spw*zoomv,sph*zoomv);
			overctx.beginPath();
			overctx.setLineDash([5,2]);
			overctx.rect(selx*zoomv,  sely*zoomv,  selw*zoomv,  selh*zoomv);
			overctx.stroke();
		
		vanselect=true;
		softselect=true;
		
        //aw.realctx.drawImage(pastedImage, 0, 0);
		}
	pastedImage.src = source;
	}
	
//==========Copy
/*event*/ //window.addEventListener("copy", copyHandler);
function copyHandler(e) {
	//var sendable="YAaY";
	var sender=aw.realc.toDataURL();
	 e.preventDefault(); //fontos
	e.clipboardData.setData('text', sender);
	//alert(e.clipboardData.types);

}

function localCopyHandler(){//alert("c");
if(vanselect && selw>0 && selh>0)localClipboard = movebuff;//aw.realctx.getImageData(selx+currentframe*spw,sely,selw,selh);
			//cut: aw.realctx.clearRect(selx+spw*currentframe,sely,selw,selh);
};
function localPasteHandler(){
		toolpick('rectselect');
		selx=0;sely=0; selw= localClipboard.width; selh= localClipboard.height;
		movebuff = localClipboard;
		tempctx.clearRect(0,0,spw,sph);			
		tempctx.putImageData(movebuff,selx,sely);
		setcurrentframe(currentframe); applytemp();
			
			

		
		startselx=selx; startsely=sely; 
		
			overctx.clearRect(0,0,spw*zoomv,sph*zoomv);
			overctx.beginPath();
			overctx.setLineDash([5,2]);
			overctx.rect(selx*zoomv,  sely*zoomv,  selw*zoomv,  selh*zoomv);
			overctx.stroke();
			
		vanselect=true;
		softselect=true;};




//window.addEventListener("save", saveHandler);
//function saveHandler(e) {alert("sssssss"); e.preventDefault();}
	
//=== /Clipboard ===============================================================




</script>



</body>
</html>
