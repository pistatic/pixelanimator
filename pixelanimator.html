<!DOCTYPE html>
<html>
<head><title>PixelAnimator</title></head>
<link rel="shortcut icon" type="image/ico" href="favicon.ico" /> 
<style>*{//border: 1px solid grey; //<-durván bezavar a pontosságnak
-moz-user-select: none; -webkit-user-select: none; -ms-user-select:none; user-select:none;}
canvas{    image-rendering: optimizeSpeed;
    image-rendering: -moz-crisp-edges;
    image-rendering: -webkit-optimize-contrast;
    image-rendering: optimize-contrast;
    -ms-interpolation-mode: nearest-neighbor;
    }

.drawcanv{ position:fixed; }
#drawoverlay{cursor: url(curpencil.cur),pointer;  position:fixed; z-index:98; }
#onioncanvas{ position:fixed; z-index:97; }
.drawheader{background:black; color:white; cursor:move; position:fixed; min-width:100px;top:0; line-height:25px; padding:0px 10px 0px 10px;  transition:color 1s;}
.drawheader_ina{background:#222222;color:gray;cursor:move;position:fixed; min-width:100px;top:0; line-height:25px; padding:0px 10px 0px 10px; transition:color 0.5s; }
.drawback{background:green;z-index:-1;position:fixed;}
#downloadTrigger{display:none;}
#saveTrigger{display:none;}
/*FloatingWindow*/
#fw_new{ 
    visibility:hidden; position:absolute; background:lightgray; border:2px solid #3c3c3c;
    color:black; z-index:100; width: 200px; height:auto; padding:5px;}

.dimmer{background: #000; position: fixed; opacity: .5;
    top:0; left:0; width:100%; height:100%; z-index:99; 
	}
.colorcube{width:25px;height:25px;border:2px solid black; background:red; transition:border 0.3s;}
.colorcube:hover{border:2px solid #FFAA00; }
#colorswatch{width:60px;height:60px; margin:0px;}
.blockmenubutton{width:30px;height:30px; display:inline-block; margin:1px; background:#FFFFFF; transition:background 0.5s;}
.blockmenubutton_ina{width:30px;height:30px; display:inline-block; margin:1px; background:#888888;}
.blockmenubutton:hover{ background:#FFAA00; }
.blockmenuface{width:100%; height:100%;}

.menuheader{position:fixed; width:100%; margin:0; top:0; left:0; height:90px; background:black; color:white;}
.toolpack{ position:absolute;  top:10px; width:250px; display:block;  }
.tp1{left:20px;}
.tp2{left:300px;}
.tp3{right:30px;}
.tp4{height:100%; left:50%; margin-left:-150px; text-align:center;}
.gradlight{background: -moz-linear-gradient(top,  rgba(255,255,255,0) 0%, rgba(255,255,255,0.47) 100%); /* FF3.6+ */
	background: -webkit-gradient(linear, left top, left bottom, color-stop(0%,rgba(255,255,255,0)), color-stop(100%,rgba(255,255,255,0.47))); /* Chrome,Safari4+ */
	background: -webkit-linear-gradient(top,  rgba(255,255,255,0) 0%,rgba(255,255,255,0.47) 100%); /* Chrome10+,Safari5.1+ */
	background: -o-linear-gradient(top,  rgba(255,255,255,0) 0%,rgba(255,255,255,0.47) 100%); /* Opera 11.10+ */
	background: -ms-linear-gradient(top,  rgba(255,255,255,0) 0%,rgba(255,255,255,0.47) 100%); /* IE10+ */
	background: linear-gradient(to bottom,  rgba(255,255,255,0) 0%,rgba(255,255,255,0.47) 100%); /* W3C */
	filter: progid:DXImageTransform.Microsoft.gradient( startColorstr='#00ffffff', endColorstr='#78ffffff',GradientType=0 ); /* IE6-9 */
	opacity:1; transition:opacity 1s;
	}

	</style>
	
	
	
<body style="background:lightgrey;">

    <div class="menuheader">
	<p id="debugp" style="display:none">debug</p>
	<div class="toolpack tp1">
		<div class="blockmenubutton" onclick="toolpick('pencil')" ><img src="icons/block_pen.svg" title="Pencil" class="blockmenuface"></div>
		<div class="blockmenubutton" onclick="toolpick('rectselect')"><img src="icons/block_rectselect.svg" title="Select" class="blockmenuface"></div>
		<div class="blockmenubutton_ina" onclick="toolpick('free-select')"><img src="icons/block_freeselect.svg" title="Free-select" class="blockmenuface"></div>
		<div class="blockmenubutton" onclick="toolpick('fill')"><img src="icons/block_fill.svg" title="Fill" class="blockmenuface"></div>
		<div class="blockmenubutton_ina"></div>
		<br>
		<div class="blockmenubutton_ina"></div>
		<div class="blockmenubutton_ina"></div>
		<div class="blockmenubutton_ina"></div>
		<div class="blockmenubutton_ina"></div>
		<div class="blockmenubutton_ina"></div>
	</div>
	
	<div class="toolpack tp2">
		<button type="button" name="newwindow" onclick="openfw(document.getElementById('fw_new'))">New...</button>
	</div>
	
	<select style="display:none" onchange="pencilpick(this.value)" id="pencilselect">
		<option value="1">.</option>
		<option value="2">.</option>
		<option value="3">+</option>
	</select>
	
	<div class="toolpack tp3">
		<input  type="color" id="colorswatch" onchange="colorpick(this.value)">
		<table id="colorgrid" style="position:absolute;top:0px;left:70px;margin:0; border:1px solid #222222;">
		 <tr> <td class="colorcube"></td><td class="colorcube"></td><td class="colorcube"></td><td class="colorcube"></td><td class="colorcube"></td><td class="colorcube"></td> </tr>
		 <tr> <td class="colorcube"></td><td class="colorcube"></td><td class="colorcube"></td><td class="colorcube"></td><td class="colorcube"></td><td class="colorcube"></td> </tr>
		</table>
	</div>
	<div class="toolpack tp4">
		<img src="icons/pixan.svg">
	</div>
	
	
	<a target="_blank" href="" onclick="exportstart(this)" download="testXXX.jpg" id="downloadTrigger">DOWNLOAD ME!</a>
	<a target="_blank" href="" onclick="savestart(this)" download="" id="saveTrigger"></a>
	<input style="display:none;" type='file' name='img' id='uploadimage' onchange="filepick(this.value)" />
	
	</div>
	


<canvas id="drawoverlay" width="800" height="600" ></canvas> 
<canvas id="onioncanvas" width="800" height="600" ></canvas> 
<canvas id="drawback" class="drawback gradlight" width="800" height="600" ></canvas> 

<div id="timelinediv" style="width:100%; height:auto; overflow:scroll; padding:0px; position:fixed; bottom:0; left:0;">
	
	
	<div id="timelinepicker" style="position:absolute; border: 2px solid red; width:50px;height:60px; display:inline-block;">e</div>
</div>
<div id="viewsettingsdiv" style="width:100%; padding:0px; position:fixed; bottom:0; left:0; background:black; color:white;">
<button onclick="animate()">Play</button>
fps:<input type="number" value=30 min=1 id="fpsinput" style="width:40px;">
zoom:×<input type="number" value=5 min=1 id="zoominput" style="width:40px;">
</div>
<br>


<div id="fw_new">
	New sheet <br>
	spw <input type="number" value=50 min=1 id="fwv_spw" style="width:40px;"> <br>
	sph <input type="number" value=60 min=1 id="fwv_sph" style="width:40px;"> <br>
	count <input type="number" value=12 min=1 id="fwv_count" style="width:40px;"> <br>
	<button onclick="createnewwindow(document.getElementById('fwv_spw').value,document.getElementById('fwv_sph').value,document.getElementById('fwv_count').value)">New</button> <button onclick="dimmer.click()">Cancel</button>
</div>

<br>

<br>

<script src="gildas-zip/zip.js"></script> 
<script>zip.workerScriptsPath="gildas-zip/"</script>

<script src="jquery-1.11.0.min.js"></script>
<script>

function btnspawn(){
var btn=document.createElement("BUTTON");
document.body.appendChild(btn);
};

var startColors=new Array({r:0,g:0,b:0},{r:255,g:255,b:255},{r:255,g:0,b:0},{r:0,g:255,b:0},{r:0,g:0,b:255},{r:125,g:0,b:125},
						  {r:255,g:125,b:0},{r:255,g:255,b:0},{r:255,g:0,b:255},{r:0,g:255,b:255},{r:122,g:122,b:122},{r:0,g:125,b:0});


function canvasresize(){
var resizebuff = aw.realctx.getImageData(0,0,aw.realc.width,aw.realc.height);
aw.realc.height+=20;
aw.realctx.putImageData(resizebuff,0,0);		
};
var undoDepth=50;
var animrunning=false;

var windowList=new Array(); /*records of open windows and their settings*/

var aw=new Object(); //ActiveWindow
//id name aw.realc (aw.realctx) (drawcanvas) (drawctx) (drawheader) (undobuff) (redobuff) spw sph spc zoomv fpsv (currentframe)
//pure global
var drawheader;
var zoomv=5;
var fpsv=15;
var currentframe=0;
var spw=50; //spritewidth
var sph=60;
var spc=30; //spritecount
var undobuff=new Array();
var redobuff=new Array();

var col={r:0,g:0,b:0};
var selx=0; var sely=0;var selw=0; var selh=0;
var dimmer;
//var tool="pencil";



function setTimelinePicker(){
var timelinepicker=document.getElementById("timelinepicker");
timelinepicker.style.color="red";
timelinepicker.style.width=(spw-10).toString()+"px";
timelinepicker.style.height=(sph-10).toString()+"px";
timelinepicker.style.top="5px";
timelinepicker.style.left=(currentframe*spw+5).toString()+"px";

viewsettingsdiv.style.bottom=(sph+25).toString() +"px"; 
}


setTimelinePicker();
var dback=document.getElementById("drawback");
var overc=document.getElementById("drawoverlay");
var onionc=document.getElementById("onioncanvas");
var overctx=overc.getContext("2d");
var onionctx=onionc.getContext("2d");
	onionctx.globalAlpha = 0.5;




    //aw.realc = document.getElementById("realcanvas"); //createElement('canvas');
    //aw.realctx = aw.realc.getContext('2d');


var tempc = document.createElement('canvas'); 
document.body.appendChild(tempc);tempc.style.position="fixed";tempc.style.top="100px";tempc.style.left="5px";
 tempc.width=spw;  tempc.height=sph; 

var tempctx = tempc.getContext('2d');

var dumpc = document.createElement('canvas'); 
var dumpctx = dumpc.getContext('2d');


//document.body
//document.getElementById("timelinediv").appendChild(aw.realc);

$('#fpsinput').bind('input', function() { fpsv=$(this).val(); });/*nem rakhatom c inicializálás elé*/
$('#zoominput').bind('input', function() { setzoom( $(this).val() ); }  ); /*nem rakhatom ctx beállítások után mert elmos; wtfff*/


        /*ctx.imageSmoothingEnabled = false;
        ctx.webkitImageSmoothingEnabled = false;
        ctx.mozImageSmoothingEnabled = false;*/
		
        onionctx.imageSmoothingEnabled = false;
        onionctx.webkitImageSmoothingEnabled = false;
        onionctx.mozImageSmoothingEnabled = false;
		
		
        


/*function applyzoom(){
var zoombuff = aw.realctx.getImageData(0,0,aw.realc.width,aw.realc.height).data; alert(zoombuff.length);
for(var i=0;i<zoombuff.length;i++){ctx.fillStyle="#000000"; ctx.fillRect((i/aw.realctx.width)*zoomv,(i%aw.realctx.width)*zoomv,zoomv,zoomv);}
} */

function trace(mit){
	document.getElementById("debugp").innerHTML = mit.toString();}

function setzoom(zv){ 
	aw.zoomv=zoomv=zv;  //c=document.getElementById("drawcanvas");
	dback.width=overc.width=onionc.width=c.width = spw*zoomv;
	dback.height=overc.height=onionc.height=c.height = sph*zoomv;
	ctx.imageSmoothingEnabled = false;ctx.webkitImageSmoothingEnabled = false;ctx.mozImageSmoothingEnabled = false;
	onionctx.imageSmoothingEnabled = false; onionctx.webkitImageSmoothingEnabled = false; onionctx.mozImageSmoothingEnabled = false;
	setcurrentframe(currentframe);
	drawheader.style.width = spw*zoomv - 20 + 'px';
	

	}

function copy()
{
var imgData=ctx.getImageData(10,10,50,50);
ctx.putImageData(imgData,10,70);
}

var img = new Image(); img.src="hoodie.png";
img.onload=function(){
  
  
  
  //ctx.drawImage(img,0,0);
  
  
  //aw.realc.width=img.width; aw.realc.height=sph;

  
  createnewwindow(50, 60, 12);
  aw.realctx.drawImage(img, 0, 0 , img.width,img.height);
  //aw.realctx.translate(0.5, -0.5);
  /*aw.realctx.lineWidth=1;
  aw.realctx.beginPath();
        aw.realctx.moveTo(1, 2);
		aw.realctx.lineTo(170, 15);
        aw.realctx.stroke();*/
  
  

  
  drawheaderinit(150,150);
  setzoom(zoomv);
  fpsv=aw.fpsv=20;
  document.getElementById('fpsinput').value=20;
  setcurrentframe(currentframe);

  
  
  
  /* // invert colors
  for (var i=0;i<imgData.data.length;i+=4)
    {
    imgData.data[i]=255-imgData.data[i];
    imgData.data[i+1]=255-imgData.data[i+1];
    imgData.data[i+2]=255-imgData.data[i+2];
    imgData.data[i+3]=255;
    }
  ctx.putImageData(imgData,0,0);*/
};
/*
var img2 = new Image();
img2.src = 'http://upload.wikimedia.org/wikipedia/commons/f/f0/Pixelart-tv-iso.png';

img2.onload = function () { 
        ctx.drawImage(aw.realc, 0, 0, aw.realc.width*zoomv, aw.realc.height*zoomv);
};
*/
function openfw(mit){
        dimmer = document.createElement("div");
		dimmer.className = 'dimmer';
    
    dimmer.onclick = function(){
        document.body.removeChild(this);   
        mit.style.visibility = 'hidden';
    }
        
    document.body.appendChild(dimmer);
    
    mit.style.visibility = 'visible'; 
    mit.style.top = window.innerHeight/2 - 50 + 'px';
    mit.style.left = window.innerWidth/2 - 100 + 'px';
    return false;

};
function createnewwindow(width,height,count){
	if(dimmer)dimmer.click();
	
	
	
	//id name aw.realc (aw.realctx) (drawcanvas) (drawctx) (drawheader) (undobuff) (redobuff) spw sph spc zoomv fpsv (currentframe)
	//changing: (tempc) (overc) (onionc) ---(timeline) (play)
	var rec={
	id:1,
	name:"new",
	realc:document.createElement('canvas'),
	drawc:document.createElement('canvas'),
	drawheader:document.createElement('div'),
	spw:parseInt(width),
	sph:parseInt(height),
	spc:parseInt(count),
	currentframe:0,
	zoomv:4,
	fpsv:30,
	undobuff:new Array(),
	redobuff:new Array(),
	setAsActive:new Function()
	}
	rec.drawctx=rec.drawc.getContext('2d');
	rec.realctx=rec.realc.getContext('2d');
	rec.realc.width=rec.spw*rec.spc;  rec.realc.height=rec.sph; 
	rec.realc.addEventListener('click',framepick , false);
	
	windowList.push(rec);
	
	
	
	
	
	document.body.appendChild(rec.drawc);
	document.body.appendChild(rec.realc);
	document.body.appendChild(rec.drawheader);
	
	rec.drawheader.className ="drawheader"
	rec.drawheader.innerHTML=rec.name;
	rec.drawheader.parentRec=rec;
	rec.drawc.className ="drawcanv";
	
	
	
	rec.setAsActive = function(){ 
	/*previously actives*/
		if(aw.realc){//if first
		aw.realc.style.display="none";
		aw.drawheader.className="drawheader_ina";
		}
	aw=rec;
	aw.realc.style.display="initial";
	aw.drawheader.className="drawheader";
	
	drawheader=rec.drawheader;
	currentWindowId=rec.id;
	//aw.realc=rec.realc;
	//aw.realctx=rec.realc.getContext('2d'); /*aw.realctx-et nem kell tárolni?*/ de
	c=rec.drawc;
	ctx=rec.drawctx;
	spw=rec.spw;
	sph=rec.sph;
	spc=rec.spc;
	currentframe=rec.currentframe;
	zoomv=rec.zoomv;
	fpsv=rec.fpsv;
	undobuff=rec.undobuff;
	redobuff=rec.redobuff;
	
	 
	 tempc.width=spw;  tempc.height=sph; 
	 
	 document.getElementById('zoominput').value=zoomv;
	 setzoom(zoomv);
	 setTimelinePicker();
	setcurrentframe(currentframe);
	
	 }
	 rec.setAsActive();
	
	document.getElementById("timelinediv").appendChild(aw.realc);
	drawheaderinit(200,200);
	
	
	drawheader.addEventListener('mousedown', drawheaderdragstart, false);
	
}




function framepick(){if(!animrunning){ commitTemp();
 mouseX=(event.pageX - $(document).scrollLeft() - $(aw.realc).offset().left);
currentframe=Math.floor(mouseX/spw);
setcurrentframe(currentframe);
}}

function setcurrentframe(currentframe)
{
  ctx.clearRect(0,0,spw*zoomv,sph*zoomv);
  ctx.drawImage(aw.realc, spw*currentframe, 0,  spw,sph,0,0,spw*zoomv,sph*zoomv);
  timelinepicker.style.left=(currentframe*spw+5).toString()+"px"; 
  timelinepicker.innerHTML=currentframe;
  if(!animrunning)setonion();
  aw.currentframe=currentframe;
}
function setonion(){if(false){
  onionctx.clearRect(0,0,spw*zoomv,sph*zoomv);
  onionctx.globalAlpha = 0.2;
  onionctx.drawImage(aw.realc, spw*(currentframe-1), 0,  spw,sph,0,0,spw*zoomv,sph*zoomv);
  onionctx.drawImage(aw.realc, spw*(currentframe+1), 0,  spw,sph,0,0,spw*zoomv,sph*zoomv);
}}

function applytemp()
{
  ctx.drawImage(tempc, 0, 0,  spw,sph,0,0,spw*zoomv,sph*zoomv);
}
function commitTemp(){ 
vanselect=false; softselect=false;
	if(undobuff.length>=undoDepth)undobuff.shift();
	var undostep = aw.realctx.getImageData( spw*currentframe, 0,  spw,sph);
	var undorec = {windowId:1, frame:currentframe, data:undostep};
	undobuff.push(undorec);
	if(redobuff.length>0)redobuff=new Array();
aw.realctx.drawImage(tempc, spw*currentframe, 0); tempctx.clearRect(0,0,spw,sph);	

overctx.clearRect(0,0,spw*zoomv,sph*zoomv);
/*	if(vanselect){
		vanselect=false;
		overctx.clearRect(0,0,spw*zoomv,sph*zoomv);
		if(softselect){
			aw.realctx.drawImage(tempc, spw*currentframe, 0);
			softselect=false;
		}
	tempctx.clearRect(0,0,spw,sph);	
	} */
}



	//requestinterval csak 60fps-nél kellene
function animate()
{if(!animrunning){currentframe=0;animrunning=true;
   //TIMER

var  timer = setInterval(function() {
  //elem.style.left = ( left += 10 ) + "px";
  setcurrentframe(currentframe);
currentframe++;
  if ( currentframe>aw.spc ) {clearInterval( timer ); animrunning=false; currentframe=0; ctx.drawImage(aw.realc, spw*currentframe, 0,  spw,sph,0,0,spw*zoomv,sph*zoomv);}
}, 1000/fpsv);
}
};


function drawheaderinit(xp,yp){
  var div = drawheader;
  var canv = c; var ocanv = overc;
  div.style.top = yp + 'px';
  div.style.left = xp + 'px';
  dback.style.top=ocanv.style.top=onionc.style.top=canv.style.top = yp + 25 + 'px';
  dback.style.left=ocanv.style.left=onionc.style.left=canv.style.left = xp + 'px';
  }

function drawheaderdragstart(e){
  if(this.parentRec!=aw)
     {this.parentRec.setAsActive(); 
	 drawback.style.transition="opacity 0s"; drawback.style.opacity=0; }
  window.addEventListener('mousemove', drawheaderdragmove, true);
  window.addEventListener('mouseup', drawheaderdragend, true);
  dhdstartX=e.clientX + $(document).scrollLeft() - $(drawheader).offset().left;
  dhdstartY=e.clientY + $(document).scrollTop() - $(drawheader).offset().top;
  drawheaderdragmove(e);
  drawback.style.transition="opacity 1s"; drawback.style.opacity=1;
  
  }
function drawheaderdragmove(e){
  var div = drawheader;
  var canv = c; var ocanv = overc;
  div.style.top = e.clientY -dhdstartY + 'px';
  div.style.left = e.clientX -dhdstartX+ 'px';
  dback.style.top=ocanv.style.top=onionc.style.top=canv.style.top = e.clientY -dhdstartY + 25 + 'px';
  dback.style.left=ocanv.style.left=onionc.style.left=canv.style.left = e.clientX -dhdstartX + 'px';
}
function drawheaderdragend(e){
  window.removeEventListener('mousemove', drawheaderdragmove, true);
  window.removeEventListener('mouseup', drawheaderdragend, true);
}



    drawoverlay.addEventListener('mousedown', drawevent, false);
    window.addEventListener('mousemove', drawevent, false);
    window.addEventListener('mouseup',   drawevent, false);
	drawoverlay.addEventListener('mouseout',   drawevent, false);
	/*window*/drawoverlay.addEventListener('contextmenu', rightclickmenu  , false);
	
	function rightclickmenu(e){e.preventDefault(); return false;}
	
	  function drawevent (e) {
    var func = tool[e.type];
	//alert(func);
    if (func) { func(e); }
  }
  
function toolpick (e) {
  commitTemp();
   tool=new tools[e];
      //tool = tools.pencil;//new tools[this.value]();
	  
    //}
  }
  
  var drawpixel = tempctx.createImageData(2,2);;
  var drawpixelsize = 2;
 function pencilpick(e){ //alert(e);
	switch(e){
	case "1": drawpixel = tempctx.createImageData(1,1); 
			drawpixel.data[0]=col.r;
			drawpixel.data[1]=col.g;
			drawpixel.data[2]=col.b;
			drawpixel.data[3]=255; 
			var drawpixelsize = 1; break;
	case "2": drawpixel = tempctx.createImageData(2,2);
			for(var i=0;i<4;i++){
			drawpixel.data[0+i*4]=col.r;
			drawpixel.data[1+i*4]=col.g;
			drawpixel.data[2+i*4]=col.b;
			drawpixel.data[3+i*4]=255;} 
			var drawpixelsize = 2; break;
	case "3":	drawpixel = tempctx.createImageData(3,3);
			for(var i=0;i<9;i++){
			drawpixel.data[0+i*4]=col.r;
			drawpixel.data[1+i*4]=col.g;
			drawpixel.data[2+i*4]=col.b;
			drawpixel.data[3+i*4]=255;} 
			var drawpixelsize = 3; break;
	
 }
 }
 pencilpick("1");
 var erasepixel = tempctx.createImageData(2,2); 
 for(var i=0;i<16;i++) erasepixel.data[i]=255;
  

function componentToHex(c) {var hex = c.toString(16); return hex.length == 1 ? "0" + hex : hex;}
function rgbToHex(r, g, b) {return "#" + componentToHex(r) + componentToHex(g) + componentToHex(b);}

function hexToR(h) {return parseInt((cutHex(h)).substring(0,2),16)}
function hexToG(h) {return parseInt((cutHex(h)).substring(2,4),16)}
function hexToB(h) {return parseInt((cutHex(h)).substring(4,6),16)}
function cutHex(h) {return (h.charAt(0)=="#") ? h.substring(1,7):h}
function colorpick (e) {
  col.r=hexToR(e);
  col.g=hexToG(e);
  col.b=hexToB(e);
  pencilpick(document.getElementById("pencilselect").value);
  document.getElementById("colorswatch").value=e;
  }

  
  
  
var colorgrid = document.getElementById("colorgrid");
for(var i=0; i<colorgrid.rows.length;i++){
for(var j=0; j<colorgrid.rows[i].cells.length;j++){

		var setcol=startColors[i*colorgrid.rows[i].cells.length + j]; 
		colorgrid.rows[i].cells[j].style.background=rgbToHex(setcol.r,setcol.g,setcol.b);
		colorgrid.rows[i].cells[j].value=rgbToHex(setcol.r,setcol.g,setcol.b);
	colorgrid.rows[i].cells[j].onclick= function(){colorGridPick(this.value);};
}}

function colorGridPick(e){colorpick(e);}
  
  
  
function matchCol(a,b){
	if(a.hasOwnProperty("a") && b.hasOwnProperty("a")) return(a.r==b.r && a.b==b.b && a.g==b.g && a.a==b.a);
	else return(a.r==b.r && a.b==b.b && a.g==b.g);
}
function getCol(pic,px,py){
	var col=new Object();
	var pos=(px+py*spw)*4;
	col.r=pic.data[pos];
	col.g=pic.data[pos+1];
	col.b=pic.data[pos+2];
	col.a=pic.data[pos+3];
	return col;
}
function setCol(pic,px,py,col){
	var pos=(px+py*spw)*4;
	pic.data[pos]=col.r;
	pic.data[pos+1]=col.g;
	pic.data[pos+2]=col.b;
	pic.data[pos+3]=255;
}
  
  
  /*
 function line(x0, y0, x1, y1)
   dx := abs(x1-x0)
   dy := abs(y1-y0) 
   if x0 < x1 then sx := 1 else sx := -1
   if y0 < y1 then sy := 1 else sy := -1
   err := dx-dy
 
   loop
     plot(x0,y0)
     if x0 = x1 and y0 = y1 exit loop
     e2 := 2*err
     if e2 > -dy then 
       err := err - dy
       x0 := x0 + sx
     end if
     if e2 < dx then 
       err := err + dx
       y0 := y0 + sy 
     end if
   end loop
   */
//currpos=(Math.floor(mouseY/zoomv)*spw+Math.floor(mouseX/zoomv))*4;
  function drawdataline(hova,lmx,lmy,mx,my){ //kimásolja a frame-t, datát módosít, visszamásol 
	dx = Math.abs(mx-lmx);
	dy = Math.abs(my-lmy);
	sx = lmx < mx ?  1 : -1;
	sy = lmy < my ?  1 : -1;
	err = dx-dy;
   
	do{ currpos=(Math.floor(lmy/zoomv)*spw+Math.floor(lmx/zoomv))*4;
  		hova.data[currpos  ]=col.r;
		hova.data[currpos+1]=col.g;
		hova.data[currpos+2]=col.b;
		hova.data[currpos+3]=255;
		
		e2= 2*err;
		if(e2 > -dy){ err = err - dy; lmx += sx}
        if(e2 < dx){ err = err + dx; lmy+= sy }

		}while(lmx!=mx || lmy!=my);
  };
  
   function drawdataline2(hova,pix,lmx,lmy,mx,my){ /*érdemesebb lenne kész x y poz-t adni?*/
	dx = Math.abs(mx-lmx);
	dy = Math.abs(my-lmy);
	sx = lmx < mx ?  1 : -1;
	sy = lmy < my ?  1 : -1;
	err = dx-dy;
   
	do{ /*currpos=(Math.floor(lmy/zoomv)*spw+Math.floor(lmx/zoomv))*4;
  		hova.data[currpos  ]=col.r;
		hova.data[currpos+1]=col.g;
		hova.data[currpos+2]=col.b;
		hova.data[currpos+3]=255;*/
		hova.putImageData(pix,Math.floor(lmx/zoomv),Math.floor(lmy/zoomv));
		 
		e2= 2*err;
		if(e2 > -dy){ err = err - dy; lmx += sx}
        if(e2 < dx){ err = err + dx; lmy+= sy }

		}while(lmx!=mx || lmy!=my);
  };
  
  function sleep(millis, callback) {setTimeout(function(){ callback(); }, millis);}
  
  /*scanline fill?*/
  function floodFill(base,temp,px,py,mit,mire){ //original ifalpha-layer
	var pos=(px+py*spw)*4;
	
	var stax=new Array();
	if(matchCol(mit,mire))return;
	var node={x:px,y:py};
	stax.push(node);
	do{
		node=stax.pop();
		if(matchCol(getCol(base,node.x,node.y),mit)){
				setCol(base,node.x,node.y,mire); 
				stax.push({x:node.x+1,y:node.y});
				stax.push({x:node.x-1,y:node.y});
				stax.push({x:node.x,y:node.y+1});
				stax.push({x:node.x,y:node.y-1}); 
			}
		}while(stax.length>0)
	return;
  }

  
  

  var tools = {}; 

 tools.pencil = function () {
    var tool = this;
    this.started = false;
	this.tracknum = 0;
	this.drawbuff =null;


    this.mousedown = function (e) {
	mouseX=(e.clientX + $(document).scrollLeft() - $(overc).offset().left);
	mouseY=(e.clientY + $(document).scrollTop() - $(overc).offset().top);
       // aw.realctx.beginPath();
        //aw.realctx.moveTo(mouseX,mouseY);
        tool.started = true;
		tool.tracknum = 0;
		//tool.drawbuff = aw.realctx.getImageData( 50*currentframe, 0,  spw,sph);
		
		tempctx.clearRect(0,0,spw,sph);	
		lastmX=mouseX;
		lastmY=mouseY;
		
		//alert(mouseY+" "+mouseX)
    };


    this.mousemove = function (e) {
	mouseX=(e.clientX + $(document).scrollLeft() - $(overc).offset().left);
	mouseY=(e.clientY + $(document).scrollTop() - $(overc).offset().top);
      if (tool.started) {
      //  aw.realctx.lineTo(mouseX, mouseY);
       // aw.realctx.stroke();
	   
		tool.tracknum++;
		
		//drawdataline(tool.drawbuff,lastmX,lastmY,mouseX,mouseY);
		
		
		
		if(e.button==0)drawdataline2(tempctx,drawpixel,lastmX,lastmY,mouseX,mouseY);
		if(e.button==2)drawdataline2(tempctx,erasepixel,lastmX,lastmY,mouseX,mouseY);
		trace(e.button);
		
	//document.getElementById("debugp").innerHTML=mouseX.toString();
	//	aw.realctx.putImageData(tool.drawbuff,50*currentframe, 0,Math.min(lastmX,mouseX)/zoomv,Math.min(lastmY,mouseY)/zoomv,Math.abs(lastmX-mouseX)/zoomv,Math.abs(lastmY-mouseY)/zoomv);	//alert(Math.min(lastmY,mouseY)-1)
		//kell aw.realctx.putImageData(tool.drawbuff,50*currentframe, 0);	
		 if(e.button==2) ctx.globalCompositeOperation="destination-out";
		 else ctx.globalCompositeOperation="source-over";
		 applytemp();
		 ctx.globalCompositeOperation="source-over";
		 //setcurrentframe(currentframe);
		lastmX=mouseX;
		lastmY=mouseY;

      }
    };

    this.mouseup = function (e) {
	mouseX=(e.clientX + $(document).scrollLeft() - $(overc).offset().left);
	mouseY=(e.clientY + $(document).scrollTop() - $(overc).offset().top);
      if (tool.started) {
        tool.mousemove(e);
		 if(e.button==2) aw.realctx.globalCompositeOperation="destination-out";
		 else aw.realctx.globalCompositeOperation="source-over";
		commitTemp();
		aw.realctx.globalCompositeOperation="source-over";
		
        tool.started = false;
      }
    };
	//this.mouseout = function (e) { if (tool.started) {tool.mouseup(e);}}
  };

  
  var vanselect=false;
  var softselect=false;
  var movebuff;
tools.rectselect = function () {
    var tool = this;
    this.started = false;
	dragstarted=false;
	

    this.mousedown = function (e) {
	mouseX=(e.clientX - $(document).scrollLeft() - $(overc).offset().left);
	mouseY=(e.clientY - $(document).scrollTop() - $(overc).offset().top);
	if(vanselect && (mouseX/zoomv>selx)&&(mouseX/zoomv<selx+selw) && (mouseY/zoomv>sely)&&(mouseY/zoomv<sely+selh) )
	/**/{ 
		if(!softselect){
			
			movebuff = aw.realctx.getImageData(selx+currentframe*spw,sely,selw,selh);
			aw.realctx.clearRect(selx+spw*currentframe,sely,selw,selh);
			tempctx.clearRect(0,0,spw,sph);			
			tempctx.putImageData(movebuff,selx,sely);
			setcurrentframe(currentframe); applytemp();
			
			

		}
		startselx=selx; startsely=sely;
		dragstarted=true; softselect=true;
		
	}
        else{tool.started = true; commitTemp();}
		startmX=mouseX;
		startmY=mouseY;
	
		
		//alert(mouseY+" "+mouseX)
    };


    this.mousemove = function (e) {
	mouseX=(e.clientX - $(document).scrollLeft() - $(overc).offset().left);
	mouseY=(e.clientY - $(document).scrollTop() - $(overc).offset().top);
	if(vanselect && (mouseX/zoomv>selx)&&(mouseX/zoomv<selx+selw) && (mouseY/zoomv>sely)&&(mouseY/zoomv<sely+selh) )
		    {document.getElementById('drawoverlay').style.cursor="move"}
		else{document.getElementById('drawoverlay').style.cursor="url(curpencil.cur),pointer";}
	  if(dragstarted){tempctx.clearRect(0,0,spw,sph);
	  selx=startselx+Math.ceil((mouseX-startmX)/zoomv); sely=startsely+Math.ceil((mouseY-startmY)/zoomv);
	  tempctx.putImageData(movebuff,selx,sely); 
	  setcurrentframe(currentframe);
	  applytemp();}
      if (tool.started || dragstarted ) {
		//showrect(,,,,)
		
		overctx.clearRect(0,0,spw*zoomv,sph*zoomv);
				    overctx.beginPath();
        overctx.setLineDash([5,2]);
		if(!dragstarted){
			if(startmX<mouseX){selx=Math.floor(startmX/zoomv); selw=Math.ceil((mouseX-startmX)/zoomv)} else {selx=Math.ceil(startmX/zoomv); selw=Math.floor((mouseX-startmX)/zoomv)}
			if(startmY<mouseY){sely=Math.floor(startmY/zoomv); selh=Math.ceil((mouseY-startmY)/zoomv)} else {sely=Math.ceil(startmY/zoomv); selh=Math.floor((mouseY-startmY)/zoomv)}
			overctx.rect(selx*zoomv,  sely*zoomv,  selw*zoomv,  selh*zoomv);
		}else{
			overctx.rect(selx*zoomv,  sely*zoomv,  selw*zoomv,  selh*zoomv);}
		
    overctx.stroke();
      }
    };

    this.mouseup = function (e) {
	mouseX=(e.clientX - $(document).scrollLeft() - $(overc).offset().left);
	mouseY=(e.clientY - $(document).scrollTop() - $(overc).offset().top);
	  vanselect=(selw!=0 && selh!=0);
	  if(dragstarted){dragstarted=false;}
      if (tool.started) {
        tool.mousemove(e);
        tool.started = false;
		temp1=Math.min(selx,selx+selw); temp2=Math.max(selx,selx+selw);
		selx=temp1; selw=temp2-temp1;
		temp1=Math.min(sely,sely+selh); temp2=Math.max(sely,sely+selh);
		sely=temp1; selh=temp2-temp1;
		
			//hangyák: overctx.lineDashOffset = 2;
		//cutrect
		//aw.realctx.fillRect(selx+spw*currentframe,sely,selw,selh); setcurrentframe(currentframe);
      }
    };
	//this.mouseout = function (e) { if (tool.started) {tool.mouseup(e);}}
  };


  
tools.fill = function () {
    var tool = this;
	this.drawbuff =null;

    this.mousedown = function (e) {
	mouseX=(e.clientX + $(document).scrollLeft() - $(overc).offset().left);
	mouseY=(e.clientY + $(document).scrollTop() - $(overc).offset().top);
		tempctx.clearRect(0,0,spw,sph);	
		tool.drawbuff = aw.realctx.getImageData( spw*currentframe, 0,  spw,sph);
		var startCol=getCol(tool.drawbuff, Math.floor(mouseX/zoomv), Math.floor(mouseY/zoomv));
		
		var colalph={r:col.r, g:col.g, b:col.b, a:255};
		floodFill(tool.drawbuff,null, Math.floor(mouseX/zoomv),Math.floor(mouseY/zoomv),startCol,colalph);
		tempctx.putImageData(tool.drawbuff,0,0);
		commitTemp();
		setcurrentframe(currentframe);

    };


    this.mousemove = function (e) {;};
    this.mouseup = function (e) {;};
	
 };
  
  
var tool=new tools['pencil'];









function undoHandler() {
 
 if(undobuff.length > 0){
	var undorec = undobuff.pop();
	//set active window to undorec.windowId
	currentframe=undorec.frame;
	
	var redorec={windowId:undorec.windowId,
			frame:undorec.frame,
			data:aw.realctx.getImageData( spw*currentframe, 0,  spw,sph) };
	
	aw.realctx.putImageData(undorec.data,currentframe*spw,0);
	setcurrentframe(currentframe);
	redobuff.push(redorec);
 }
 }
 
function redoHandler() {
  if(redobuff.length > 0){
	var redorec = redobuff.pop();
	//set active window to redorec.windowId
	currentframe=redorec.frame
	
	var undorec={windowId:redorec.windowId,
			frame:redorec.frame,
			data:aw.realctx.getImageData( spw*currentframe, 0,  spw,sph) };
	
	aw.realctx.putImageData(redorec.data,currentframe*spw,0);
	setcurrentframe(currentframe);
	undobuff.push(undorec);
 }
 }
 
function exportHandler() {
	//var savedimage = aw.realc.toDataURL("image/png").replace("image/png", "image/octet-stream");  // if you dont replace you will get a DOM 18 exception.
	//window.location.href=savedimage;
	//savestart(document.getElementById("downloadTrigger"))
	document.getElementById('downloadTrigger').click();
	return false;
 }
 
function exportstart(e)
	{e.href=aw.realc.toDataURL("image/png").replace("image/png", "image/octet-stream");
	e.download=aw.name+".png"; /*callback needed?*/
 }


function importHandler() { //var r=confirm("szöveg"); if(r)...
	document.getElementById('uploadimage').click();
 }
function filepick(e){ //for import
	//set aw.realctx()
	var img=new Image();
	f = document.getElementById("uploadimage").files[0],
        url = window.URL || window.webkitURL,
        src = url.createObjectURL(f);

    img.src = src;
	img.onload = function() {
	aw.realc.width=img.width;
	aw.realctx.drawImage(img, 0, 0 , img.width,img.height);
	}
}

function saveHandler() {
	document.getElementById('saveTrigger').click();
	return false;
}
function savestart(e) {
	// create the blob object storing the data to compress
	var blob2 = new Blob([ "Lorem ipsum dolor sit amet, consectetuer adipiscing elit..." ], {
	type : "text/plain"
	});
	var img=new Image();
	
	var blob = aw.realc.toDataURL("image/png");
	
	// creates a zip storing the file "lorem.txt" with blob as data
	// the zip will be stored into a Blob object (zippedBlob)
	var URLObj = window.URL || window.webkitURL;
	
	zipBlob("lorem.png", blob, function(zippedBlob) {
	 e.href=URLObj.createObjectURL(zippedBlob);
	e.download=aw.name+".zip";
	});

	function zipBlob(filename, blob, callback) {
	// use a zip.BlobWriter object to write zipped data into a Blob object
	zip.createWriter(new zip.BlobWriter("application/zip"), function(zipWriter) {
		// use a BlobReader object to read the data stored into blob variable
		zipWriter.add(filename, new zip.Data64URIReader(blob), function() {
		// close the writer and calls callback function
		zipWriter.close(callback);
		});
	}, onerror);
	}
	
	
	/*function zipBlob(filename, blob, callback) {
	// use a zip.BlobWriter object to write zipped data into a Blob object
	zip.createWriter(new zip.BlobWriter("application/zip"), function(zipWriter) {
		// use a BlobReader object to read the data stored into blob variable
		zipWriter.add(filename, new zip.BlobReader(blob), function() {
		// close the writer and calls callback function
		zipWriter.close(callback);
		});
	}, onerror);
	}*/



	function onerror(message) {console.error(message);}
}

function openHandler() {alert("open");}


function keyPress(e) {
      var evtobj = window.event? event : e
      if (evtobj.keyCode == 90 && evtobj.ctrlKey) undoHandler(); //ctrl z
	  if (evtobj.keyCode == 32 && evtobj.ctrlKey) undoHandler(); //ctrl space	  
	  if (evtobj.keyCode == 89 && evtobj.ctrlKey) redoHandler(); //ctrl y
	  if (evtobj.keyCode == 83 && evtobj.ctrlKey) saveHandler(); //ctrl s
	  if (evtobj.keyCode == 79 && evtobj.ctrlKey) openHandler(); //ctrl o
	  if (evtobj.keyCode == 69 && evtobj.ctrlKey) exportHandler(); //ctrl e
	  if (evtobj.keyCode == 73 && evtobj.ctrlKey) importHandler(); //ctrl i	  
	  //if (evtobj.keyCode == 80 && evtobj.ctrlKey) clipboardPasteHandler(); //ctrl p	  
	  if (evtobj.keyCode == 37 )setcurrentframe(--currentframe) ; //left
	  if (evtobj.keyCode == 39 )setcurrentframe(++currentframe) ; //right
	  if (evtobj.keyCode == 13 ) animate(); //enter

}

document.onkeydown = keyPress;

//disabling auto ctrl s/o  -disabling at keyDOWN
document.addEventListener("keydown", function(e) {
  if ( ((e.keyCode == 79)||(e.keyCode == 83)) && e.ctrlKey ) { e.preventDefault(); }
	}, false);


	
	


//=== Clipboard ================================================================

//firefox
/*
var pasteCatcher;
if (!window.Clipboard){
	pasteCatcher = document.createElement("div");
	pasteCatcher.setAttribute("id", "paste_ff");
	pasteCatcher.setAttribute("contenteditable", "");
	pasteCatcher.style.cssText = 'opacity:0;position:fixed;top:0px;left:0px;';
	pasteCatcher.style.marginLeft = "-20px";
	document.body.appendChild(pasteCatcher);
	pasteCatcher.focus();
	document.addEventListener("click", function(){
		//pasteCatcher.focus();
		});
	document.getElementById('paste_ff').addEventListener('DOMSubtreeModified',function(){
		if(pasteCatcher.children.length == 1){
			img = pasteCatcher.firstElementChild.src;
            
            var img2 = new Image();
            img2.onload = function(){
                ctx.drawImage(img2, 0, 0);
                }
            img2.src = img;
            //ctx.drawImage(img, 0, 0);
         
            
            //ctx.drawImage(img, 0, 0);
			pasteCatcher.innerHTML = '';
			}
		},false);
	}
//chrome
window.addEventListener("paste", pasteHandler);
function pasteHandler(e){
	if(e.clipboardData) {
		var items = e.clipboardData.items;
		if (items){
			for (var i = 0; i < items.length; i++) {
				if (items[i].type.indexOf("image") !== -1) {
					var blob = items[i].getAsFile();
					var URLObj = window.URL || window.webkitURL;
					var source = URLObj.createObjectURL(blob);
					paste_createImage(source);
					}
				}
			}
		// If we can't handle clipboard data directly (Firefox),
		// we need to read what was pasted from the contenteditable element
		else{
			}
		}
	else{
		setTimeout(paste_check_Input, 1);
		}
	}
function paste_check_Input(){
	var child = pasteCatcher.childNodes[0];
	pasteCatcher.innerHTML = "";
	if (child){
		if (cild.tagName === "IMG"){
			paste_createImage(child.src);
			}
		}
	}
function paste_createImage(source){
	var pastedImage = new Image();
	pastedImage.onload = function() {
        aw.realctx.drawImage(pastedImage, 0, 0);
		}
	pastedImage.src = source;
	}
	
*/	

/*VERZIÓ 2*/

if (!window.Clipboard) {
   var pasteCatcher = document.createElement("div");
    
   // Firefox allows images to be pasted into contenteditable elements
   pasteCatcher.setAttribute("contenteditable", "");
    
   // We can hide the element and append it to the body,
   pasteCatcher.style.opacity = 0;
   document.body.appendChild(pasteCatcher);
 
   // as long as we make sure it is always in focus
   pasteCatcher.focus();
   document.addEventListener("click", function() { pasteCatcher.focus(); });
} 
// Add the paste event listener
/*event*/ //window.addEventListener("paste", pasteHandler);
 
/* Handle paste events */
function pasteHandler(e) {
   // We need to check if event.clipboardData is supported (Chrome)
   if (e.clipboardData) {
      // Get the items from the clipboard
      var items = e.clipboardData.items;
      if (items) {alert(items[0].type);
         // Loop through all items, looking for any kind of image
         for (var i = 0; i < items.length; i++) {
            if (items[i].type.indexOf("image") !== -1) {
               // We need to represent the image as a file,
               var blob = items[i].getAsFile();
			     // and use a URL or webkitURL (whichever is available to the browser)
               // to create a temporary URL to the object
               var URLObj = window.URL || window.webkitURL;
               var source = URLObj.createObjectURL(blob);
                
               // The URL can then be used as the source of an image
               createImage(source);
            }
         }
      }
   // If we can't handle clipboard data directly (Firefox), 
   // we need to read what was pasted from the contenteditable element
   } else {
      // This is a cheap trick to make sure we read the data
      // AFTER it has been inserted.
      setTimeout(checkInput, 1);
   }
}
 
/* Parse the input in the paste catcher element */
function checkInput() {
   // Store the pasted content in a variable
   var child = pasteCatcher.childNodes[0];
 
   // Clear the inner html to make sure we're always
   // getting the latest inserted content
   pasteCatcher.innerHTML = "";
    
   if (child) {
      // If the user pastes an image, the src attribute
      // will represent the image as a base64 encoded string.
      if (child.tagName === "IMG") {
         createImage(child.src);
      }
   }
}
 function createImage(source){
	var pastedImage = new Image();
	pastedImage.onload = function() {
		toolpick('rectselect');
		selx=0;sely=0; selw=dumpc.width = pastedImage.width; selh=dumpc.height = pastedImage.height;
		dumpctx.drawImage(pastedImage,0,0,selw,selh);
		movebuff = dumpctx.getImageData(0,0,selw,selh);
		tempctx.clearRect(0,0,spw,sph);			
		tempctx.putImageData(movebuff,selx,sely);
		setcurrentframe(currentframe); applytemp();
			
			

		
		startselx=selx; startsely=sely; 
		vanselect=true;
		softselect=true;
		
        //aw.realctx.drawImage(pastedImage, 0, 0);
		}
	pastedImage.src = source;
	}
	
//==========Copy
/*event*/ //window.addEventListener("copy", copyHandler);
function copyHandler(e) {
	//var sendable="YAaY";
	var sender=aw.realc.toDataURL();
	 e.preventDefault(); //fontos
	e.clipboardData.setData('text', sender);
	//alert(e.clipboardData.types);

}

//window.addEventListener("save", saveHandler);
//function saveHandler(e) {alert("sssssss"); e.preventDefault();}
	
//=== /Clipboard ===============================================================




</script>



</body>
</html>
